\documentclass[USenglish,oneside,twocolumn]{article}

\usepackage{etex}
\usepackage[big]{dgruyter_NEW}
\usepackage[justification=centering]{caption}
\usepackage[justification=centering]{subcaption}
\captionsetup{compatibility=false}
\usepackage[ruled,algosection,noend,linesnumbered]{algorithm2e}
\usepackage{adjustbox}
\usepackage{mathtools}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
\usepackage{amsfonts}
\usepackage{stmaryrd}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{color}
\usepackage{float}

\usepackage{tikz}
\usetikzlibrary{shapes, positioning, matrix, backgrounds, decorations.pathreplacing}

\newtheorem{privdef}{Privacy Definition}
\newtheorem*{secgme}{Security Game}
\newtheorem{secthm}{Security Theorem}
\newtheorem{seccjt}{Security Conjecture}
\newtheorem{seclem}{Security Lemma}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}


\newenvironment{subproof}[1][\proofname]{%
  \renewcommand{\qedsymbol}{$\blacksquare$}%
  \begin{proof}[#1]%
}{%
  \end{proof}%
}

\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}
\newcommand{\raphael}[1]{\textcolor{blue}{Raphael: #1}}
\newcommand{\george}[1]{\textcolor{green}{George: #1}}

\cclogo{\includegraphics{by-nc-nd.pdf}}
  
\begin{document}
 
\author[1]{Raphael R. Toledo}

\author[2]{George Danezis}

\affil[1]{University College London (r.toledo@cs.ucl.ac.uk)}

\affil[2]{University College London (g.danezis@ucl.ac.uk)}

  \title{Mix-ORAM: Using delegated shuffles.}

  \begin{abstract}
{
Oblivious RAM is a key technology for securely storing data on untrusted storage but is commonly considered impractical due to its high overhead. To ensure full privacy, the database has to be periodically randomized, i.e. re-encrypted and shuffled, by the client. The computation and communication costs the client incurs are in reality super linear in the number of records, this very price deters the use of ORAM for most applications. We propose in this paper to increase ORAM's practicality by delegating the randomization process to semi-trusted third parties such that the clients do not sustain to the corresponding overhead. To do so, we present four different designs inspired by mix-net technologies and evaluate them. \todo{results}
}
\end{abstract}
  \keywords{Oblivious RAM, Mix-net, Private Queries}
%  \classification[PACS]{}
%  \communicated{...}
%  \dedication{...}

\journalname{Proceedings on Privacy Enhancing Technologies}
%\DOI{10.1515/popets-2016-0035}
%\startpage{1}
%\received{2016-02-29}
%\revised{2016-06-02}
%\accepted{2016-06-02}

%\journalyear{2016}
%\journalvolume{2016}
%\journalissue{4}

\maketitle
%
\section{Introduction}\label{Introduction}
%

Cloud technologies offer the ability to save impressive amounts of data safely and privately on remote servers. To do so, not only the data integrity must be preserved but also the confidentiality of the data content and meta data from both external adversaries and the cloud itself.
Cryptographic measures are thereby taken such as secure communication channels, user authentication, data encryption and integrity checking.
These actions, however, do not prevent the leakage of all meta data: the server owner can monitor user activities and watch which records were accessed. \\


Oblivious RAM (ORAM)~\cite{goldreich87}, or Oblivious Storage (OS)~\cite{boneh2011}, precisely prevents an adversary from observing the record access, and do so by introducing a pairing of virtual and real, or remote and local, indices. In these schemes, the records are encrypted and permuted before being uploaded to the untrusted storage and the information to decrypt the records, the encryption keys, and make the matching between the remote and local indices, a pseudo random generator seed for instance, is saved locally. When the user seeks a given record, the local client computes with the seed the corresponding remote index, fetches the encrypted data block obliviously and decrypts it. After a number of accesses, in order to render any leaked information obsolete, the database is fetched and before being uploaded back to the remote server, encrypted and shuffled once again during a so called eviction process.

This eviction is the main bottleneck of ORAM. Indeed, we assume in such design that the number of records stored remotely is orders of magnitude higher than the client storage. As every record must be re-encrypted and permuted locally to ensure nothing is leaked, the client has to download and process the database by chunks, and do so several times to undeniably hide from the adversary the records' ordering. Thus as the the database size grows, the randomization cost rises super linearly.\\

Mix networks~\cite{chaum1981untraceable} are anonymity systems whose goal is to obliviously shuffle packets. A batch of packets is processed by the mix-net in that each mix re-encrypts, or decrypts, and shuffles the packets before sending them to the next mix. For the adversary to link the mix-net's input and output, all of the mixes used in the shuffling have to be compromised.
As the mixes perform all the operations needed in ORAM, mix-nets inspired designs could thus address the delegation of ORAM's randomization process. The total cost of the eviction would however increase as several mixes are needed to ensure the confidentiality of the randomization and that the computation and communication costs are linear in the number of mixes. If using these designs, methods to amortize the eviction must be taken into account to make the randomization practical.\\

In this work, we present several privacy friendly distributed systems inspired by mix-nets to safely delegate ORAM's randomization process to semi-trusted third parties.
The advantages of such practices are, besides the reduction of the client computation, the possibility to delay the eviction to quieter times, the database availability during the eviction process regardless of the ORAM design and the independence from centralized parties.\\

\noindent Our contributions are listed as following:
\begin{itemize}
 \item We present and motivate the use of mix-net to construct ORAM schemes.
 \item We present a number of designs, improve them with load balancing via parallel mixing and compare their costs and efficiency.
 \item evaluation
 \item implementation
\end{itemize}

We present the related work, the ORAM model, its associated threat model and explaining the different costs in Section~\ref{Related} and~\ref{Prelim}, we use random transposition shuffles them in ORAM and together with a mixnet and discuss various optimizations in Section~\ref{Mix-ORAM}. We then present our implementation and compare the costs with several designs in Section~\ref{Evaluation}.
We finally evaluate our schemes and discuss about the advantages and drawbacks of using mix-nets.
%

\section{Related Work}\label{Related}
\noindent\textbf{ORAM.}
ORAM was first presented by Goldreich and Ostrovsky in 1990~\cite{ostrovsky1990efficient} to prevent reverse engineering and protect softwares run on tamper resistant CPU. In 2011, ORAM solutions, called Oblivious Storage (OS)~\cite{boneh2011}, were introduce to protect data stored on untrusted remote servers.
Since then, several types of enhancement have been proposed including \textit{data structures} diversification~\cite{goldreich1996software,stefanov2011towards,stefanov2013path,ren2014ring} with trees, partitions and hierarchichal solutions appearing,
the use of more and more sophisticated \textit{security definitions} with statistical security~\cite{damgaard2011perfectly,ajtai2010oblivious} and differential privacy~\cite{wagh2016root}, and the revision of \textit{item lookups} with cuckoo hashing~\cite{pinkas2010oblivious} and bloom filters~\cite{williams2008building}.
Most ORAM constructions are based on a single client-server model, but multi-user designs were gradually introduced as \cite{backesanonymous} in 2016 which also provides user anonymity, some relying on access control~\cite{franz2011oblivious} or group access~\cite{goodrich2012privacy}.
The eviction process is one of the principal problems of ORAM, the clients have to re-encrypt and process the whole database, a lengthy process during which record access is usually not possible, some designs permitting read while shuffling as \cite{boneh2011}.\\

\noindent\textbf{Shuffling and Sorting.}
Shuffle and sorting algorithms are a thoroughly researched subject central to ORAM for the randomization process. However most of the existing methods are not useful for ORAM as they are not oblivious -in that the permutations done depends on the data itself-.

Examples of oblivious sorting algorithms include sorting networks such as Batcher's~\cite{batcher1968sorting} and the ones based on AKS~\cite{ajtai19830} which unfortunately were proved to be impractical because of the high number of I/Os, Batchers using $\mathcal{O}\left ( n \log n \right)$ I/Os and AKS having a high constant factor, but also more recent and efficient ones~\cite{paterson1990improved}.
The randomized Shellsort~\cite{goodrich2010randomized} is an elegant simple data-oblivious version of the Shellsort algorithm running in $\mathcal{O}\left ( n \log n \right)$ time that sorts with high probability.
The Zig Zag sort~\cite{goodrich2014zig}, presented in 2014, is the deterministic data-oblivious variant of the Shellsort with running time of $\mathcal{O}\left ( n \log n\right)$.
Lastly, the bucket sort Algorithm was studied in Melbourne shuffle~\cite{ohrimenko2014melbourne} where a user rely on temporary arrays and dummies and in~\cite{goodrich2012anonymous} where the authors assess the information leakage due  the use of a partially compromised parallel mix-net.\\

\noindent\textbf{Mix-nets.}
Mix-nets were first presented for anonymous e-mailing by David Chaum in 1981~\cite{chaum1981untraceable}. As they became popular many improvements were made over the years~\cite{moller2003mixmaster,danezis2003mixminion,danezis2004minx,danezis2009sphinx}. Mix-nets' main goal is to give users some anonymity by hiding the correspondence between the incoming users' packets and the mix-nets output. To do so, the users' packets go through several mixes which permute them and refresh their encryption. Either reencryption~\cite{wikstrom2006adaptively} and onion encryption can be used, proofs of shuffle~\cite{groth2007verifiable,groth2007non,bayer2012efficient} and Randomized Partial Checking~\cite{jakobsson2002making} can help verify the shuffle correctness.

This work is inspired by the mix-net technology for its encryption and permutation functionalities, however, only the packet unlinkability property is of interest for ORAM. From now on, we refer traditional ORAM solutions as ORAM and our designs as Mix ORAM.
%
\section{Preliminaries}\label{Prelim}
%
\subsection{Model}\label{Model}

Oblivious RAM systems rely on two data arrays, one we call \emph{database} and comprises the user's encrypted records and some dummies, and a temporary one we call \emph{cache}, e.g. the shelter in~\cite{goldreich87}, of lesser size so that it fits on the client and used to store the fetched records in order to hide the number of times they were accessed. We also assume the client has access to an index making the matching between records' addresses and names, and envisage an additional ORAM memory to store information about the eviction process.\\

\noindent\textbf{Access method:} To do a read or write operation, the client first downloads the cache and checks whether the desired record is present, if so a dummy is fetched from the database else the desired record. Finally, the fetched element is encrypted and if it is a read operation else overwritten with the provided data for a write operation. The element is then stored locally in the cache before the latter is sent back to the remote server.\\

\noindent\textbf{Eviction method:} When the cache is full, the client needs to start the eviction process to empty it and randomize the database. To do so, the client first \textit{rebuilds} the database by merging the cache and the database obliviously and afterwards, starts the \textit{oblivious shuffle}.

\noindent The \emph{rebuild phase} consists in placing obliviously records from the cache back to the ORAM database. The client begins by downloading the cache, then re-encrypts the records and discards any dummies contained within it. It next fetches all the records previously accessed from the database, and overwrites them one by one with their cached version or with a dummy before updating them back in the database. The cache is now empty.

\noindent The client starts \emph{the oblivious shuffle} by selecting a set of mixes from the mix-net and sending to them randomization instructions containing the list of participating mixes and the seeds used for shuffling and encrypting. When receiving the records, the first mixes fetch the database, encrypt the records, shuffle and transmit them to the next mixes according to these instructions.

\subsection{Security definitions and Threat model}\label{Threat}

We presume here of the existence of motivated adversaries trying to subvert a target user's privacy and perhaps compromise his data integrity. We assume the target user utilizes an ORAM system, compliant with the Privacy Definition~\ref{def:Oram} introduced by Stefanov et al.~\cite{stefanov2011towards}, to protect his data.
We futhermore assume that all communication between the client, ORAM server and mixes may be intercepted as in the \textit{global passive adversary} assumption however only message timing, volume and size from honest parties can be known thanks to packet encryption.
Finally, we suppose the adversaries have corrupted a number of machines to achieve their goal, unless said otherwise, the ORAM server and all but one mix are considered compromised. We will assume that the compromised machines behave in a \textit{honest but curious} way in that every operation is correctly performed but passively recorded and shared with the adversaries.

\begin{privdef}\label{def:Oram}
Let's denote a sequence of $k$ queries $\text{seq}_k=\{(\text{op}_1, \text{ad}_1, \text{data}_1), \text{ ...},(\text{op}_k, \text{ad}_k, \text{data}_k)\}$, where $op$ denotes a read or write operation, $ad$ the address where to process the operation and $data$ the block to write if needs be else $\perp$.
We denote by $ORAM(seq_k)$ the resulting randomized data access from the ORAM process with input $seq_k$.
The ORAM guarantees that $ORAM(seq_k)$ and $ORAM(seq'_{k'})$ are computationally indistinguishable if their lengths are equal ($k=k'$).
\end{privdef}

This work focuses on the ORAM eviction process and more precisely on the oblivious shuffle phase where sequences of data-blocks are shuffled and encrypted in order to hide the records indices after access information has leaked. This problem refers to in the Square Root solution~\cite{ostrovsky1990efficient} the eviction of the shelter in the database and in the Hierarchical case~\cite{goldreich1996software} the eviction of upper partitions in a lower ones. We evaluate our designs with the following Security Game~\ref{def:Game} and consider the adversaries have won the game when discovering the ordering of the remote records.

%
\begin{secgme}
An adversary gives to the user two ORAM query sequences $\text{seq}_k$ and $\text{seq}_k'$ of the same size. The user chooses randomly one of the two, executes it and start the eviction. At the end of the eviction the adversary picks which ORAM query sequence was chosen. The adversary wins if the right sequence is chosen with probability higher than $\Pr = \frac{1}{2}+\epsilon$, with $\epsilon\ll\frac{1}{2}$.
\label{def:Game}
\end{secgme} 
%

\noindent\textbf{Rationales.} We consider here an ORAM remote server consisting of a database with memory of $n\ b$-bit long data blocks and a cache with memory of $s,\ s\ll n,\ b$-bit long data blocks. We furthermore consider a mix-net composed of $m$ mixes with memory of $n/m$ data blocks, and a client with memory of $s$ data blocks. The ORAM server, the mixes and the client additionally have a small memory of capacity $\mathcal{O}(m)$ to store extra information about permutation and encryption.\\

\noindent\textbf{Costs.} We denote the communication costs by $\omega_M$ for the number of \emph{bits} sent by the ORAM, $\gamma_M$ by the client, and $\mu_M$ sent per mix. 
We group aggregate all the computation costs (encryption, shuffle and secret generation), and denote them $\omega_P$ for the ORAM, $\gamma_P$ for the client, and $\mu_P$ per mix. 
%
\subsection{Cryptographic Primitives}

\noindent\textbf{PRG \& Seeds.}
ORAM systems make use of pseudo random generators (PRG) and seeds to make the matching between remote and real indices. A distribution $\mathcal{D}$ over strings of length $l$ is said pseudo random if $\mathcal{D}$ is indistinguishable from the uniform distribution over strings of length $l$~\cite{katz2014introduction}. That means it is infeasible for any polynomial-time adversary to tell whether the string was sampled accordingly to $D$ or was chosen uniformly at random. A PRG is a deterministic algorithm that receives as an input a short random key and stretches it into a long pseudo random stream.\\\

\noindent\textbf{Encryption.}
ORAM designs heavily rely on encryption mechanism to obfuscate the database records as the records must be re-encrypted during the eviction and access processes.

Advanced Encryption Standard (AES)~\cite{daemen2013design} was conceived for high speed and low RAM requirements. It can present throughput over 700 MB/s per thread on recent CPUs such as the Intel Core i3~\cite{mcwilliams2014hardware} which makes it the ideal choice for ORAM.

To minimize the size of the instructions stored and sent by the client, we make use of elements of a cyclic group of prime order satisfying the decisional Diffie-Hellman assumption. The mixes make use of these elements and derive the different permutation seeds and encryption keys with the a key derivation function, such as the HKDF~\cite{krawczyk2010cryptographic}, and refresh the them at each round by blinding them with the shared secrets as in \cite{danezis2009sphinx}. 
%
\section{Mix-ORAM}\label{Mix-ORAM}
In this section, we first introduce two different methods we use to randomize the records during the eviction. We then present simple but expensive Mix-ORAM schemes before optimizing them with the use of distributed shuffle algorithms. 
%
\subsection{Mix and User encryption methods}\label{Enc}
We present here two ways to delegate the eviction process to a semi-trusted mix-net. For each method, we show how the mix-net encrypts and permutes the records and how the client recovers a record plain text.
We make the assumption that all data has first been encrypted with the client private keys  before using ORAM. \\

\noindent\textbf{Layered method.} In the Layered method, we use the data structure shown in Table~\ref{ldata} composed of an IV token, and a label appended to the record, e.g. the record local indices. The underlying principle of the layered method is to let the number of encryption and permutation layers grow. The records are encrypted and permuted by the mixes during the eviction, and only decrypted by the client during the access. We moreover make use of the record index to store the current remote indices. % The index takes up $n\cdot log(n)$ bits, 50 MB can store more that $10^8$ indices. 
Before sending the records to the ORAM database, the client first needs to encrypt and permute them. Each record is thus appended with its local index making together the data in the data structure and a random IV token. The records are then encrypted with the client secret key as stated in Algorithm~\ref{alg:lencp}, and permuted with a newly generated random seed stored locally. Finally the record index is updated with the new record indices. The encryption keys, permutation seeds and the record index may be uploaded to the extra space of the ORAM database.\\

\begin{table}[H]
\begin{minipage}[t][][b]{.475\textwidth}
\vspace{0pt}
\centering
\begin{tabular}{|c|c|}
IV token  &  data = label | record  \\
$8\cdot\ceil{\log(n)/8}$ bit  &  $8\cdot\ceil{\log(n)/8}+b$ bit   \\
\end{tabular}
\centering
\caption{Layered method data structure.}
\label{ldata}
\end{minipage}
\end{table}

During the eviction, the mixes encrypt both the IV token and the data separately as in Algorithm~\ref{alg:lencp}. They first generate an initialisation array from the IV token and use it to encrypt the data with keys derived from the secrets shared with the client. The first bits of the data are then used to generate another IV to encrypt with the IV token. Before sending the records to the next mixes, the data block needs to be permuted. To do so, the mixes derive from the shared secrets permutation seeds from which the new orders are generated, the data blocks are then sorted according to them.\\

\begin{algorithm}
\SetKwComment{Comment}{//}{}
\DontPrintSemicolon
\KwIn{Record $rec$; \\ \qquad Encryption key $k$; }
$IV0 \gets PRF(rec.token\cdot k, 128)$;\\
$rec.data \gets enc\left(k,\ IV0,\ rec.data \right )$;\\
$IV1 \gets PRF(rec.data \cdot k, 128)$;\\
$rec.token \gets enc\left(k,\ IV1,\ rec.token \right )$;\\
\KwOut{rec}
\caption{Layered encryption primitive}
\label{alg:lencp}
\end{algorithm}

When retrieving a record, the client needs to decipher all encryption layers. As the number of encryption layers per record varies, a timing attack can occur letting the adversary guess when the record was last fetched. To prevent the attack, we modify the access method so that the decryption happens offline (c.f. Algorithm~\ref{alg:lacc}). After retrieving a record, the client now directly encrypts it with its own key and updates it in the cache stored locally. The local cache is then uploaded to the remote server.
After doing so, if it is a write operation, the client overwrite the record with its new version. If it is a read operation, the client locally decrypts the previous encryption and remove the mix encryption layers. And finally, the client save locally an encrypted version of the record.\\ 

\begin{algorithm}
\SetKwComment{Comment}{//}{}
\DontPrintSemicolon
\KwIn{ Local record index $index$; \\ \qquad Operation and data $op,\ towrite$; \\ \qquad Encryption and permutation keys $k,\ \sigma$;\\ \qquad Saved records $recs$;\\ \qquad Number of rounds r;}
$j \gets recover\_index(\sigma,\ index)$;\\
$cache \gets fetch\_cache()$;\\
\ForAll {$rec \in cache$}
{
$cache[rec]\gets \textbf{decrypt}(k,\ r,\ \sigma,\ cache[rec])$;\\
}
\If{$record \in cache$}
{
$tofetch \gets choose\_dummy()$;\\
}
\Else
{
$tofetch \gets tofetch \{j\}$;\\
}
$record \gets fetch\_record(tofetch, cache)$\\
$update\_cache(recs \cup \textbf{encrypt}(record))$;\\
$send\_cache()$;\\

\If {$op!=read$}
{
$record \gets \{towrite\}$;\\
}
\Else
{
$record \gets \textbf{decrypt}(k,\ r,\ \sigma,\ record)$;\\
}
$save\_in\_recs(\textbf{encrypt}(k,\ record))$;\\
\KwOut{record}
\caption{Layered access method}
\label{alg:lacc}
\end{algorithm}

To decrypt a record, the client uses a trial error Algorithm~\ref{alg:ldec} based on a  decryption routine. The client first removes the client encryption, executes the routine $r$ times with the shared secrets and decrypts the data block another time with its private key. If it reads the right label, the process stops, if not the data-block is re-encrypted and it starts again.\\

\begin{algorithm}
\SetKwComment{Comment}{//}{}
\DontPrintSemicolon
\KwIn{Record and index $record,\ index$;  \\ \qquad Shared encryption keys $k_{mix,eviction,round}$;\\ \qquad Private key $prv$;\\ \qquad Number of rounds $r$; \\ \qquad Permutation seeds $\sigma$;}
$j,e=0$;\\
$r\gets \textbf{decrypt\_rtn}(prv_e,rec)$;\\
\While{$rec.data.label != i$}
{
\If {$e!=0$}
{
$rec \gets encrypt(prv_{e+1},\ rec)$;\\
}
\ForAll{$k \in \llbracket 1 :r \rrbracket $}
{
	$m\gets retrieve\_mix(\sigma,\ e,\ j,\ index)$;\\
	$rec \gets \textbf{decrypt\_rtn}(k_{m,\ e,\ j}, rec)$;\\
	$j\gets j-1$;\\
}
	$rec \gets \textbf{decrypt\_rtn}(prv_e,\ rec)$;\\
    $e\gets e-1$;\\
}
\KwOut{rec}
\caption{Layered Decryption algorithm}
\label{alg:ldec}
\end{algorithm}

The routine, written in Algorithm~\ref{alg:ldecp}, consists in decrypting the record in the opposite way of the encryption. The IV token is first decrypted thanks to an IV generated from the data and the decryption key. It is then used to generate another IV used this time to decrypt the data.
 
\begin{algorithm}
\SetKwComment{Comment}{//}{}
\DontPrintSemicolon
\KwIn{Record $rec$; \\ \qquad Decryption key $k$; }
$IV1 \gets PRF(rec.data \cdot k, 128)$;\\
$rec.token \gets dec\left(k,\ IV1,\ rec.token \right )$;\\
$IV0 \gets PRF(rec.token\cdot k, 128)$;\\
$rec.data \gets dec\left(k,\ IV0,\ rec.data \right )$;\\
\KwOut{rec}
\caption{Layered decryption routine}
\label{alg:ldecp}
\end{algorithm}

\begin{figure*}
\begin{tikzpicture}[auto, semithick, node distance= 6.5em]
\tikzstyle{every state}=[fill=white,draw=black,thick,text=black]
\node[draw, cylinder, shape border rotate=90, minimum height=3em,minimum width=2em,  label={[align=center, yshift=1em]\textbf{Status}\\$E_{k0}, (\Pi_\sigma, E_{k1})$}]    	(X)				  {DB};
\node[draw, rectangle, align=center, label=below:{$D\left ( k_0  \right )$}]   		(A)[right of=X]   {$\Pi_{\sigma}^{-1}$};
\node[draw, rectangle, align=center, label=above:{$E\left ( k_{10}'  \right )$}, label=below:{$D\left ( k_{10}  \right )$}]    		(B1)[right of=A]    { $\ $\\$\ $ };
\node[draw, rectangle, align=center, label=above:{$E\left ( k_{11}'  \right )$}, label=below:{$D\left ( k_{11}  \right )$}]    		(B2)[right of=B1]   { $\ $\\$\ $};
\node[draw, rectangle, align=center, label=above:{$E\left ( k_{12}'  \right )$}, label=below:{$D\left ( k_{12}  \right )$}]    		(B3)[right of=B2]   { $\ $\\$\ $};
\node[draw, rectangle, align=center, label=above:{$E\left ( k_0'  \right )$}]    		(C)[right of=B3]   {$\Pi_{\sigma'}$};
\node[draw, cylinder, shape border rotate=90, minimum height=3em,minimum width=2em, label={[align=center, yshift=1em] \textbf{Status}\\$E_{k0'}, (\Pi_{\sigma'}, E_{k1'})$}]    	(Y)[right of=C]	  {DB};

\draw[decoration={brace, amplitude=1em}, decorate]  ([yshift=2em, xshift=-1em]A.north west) -- ([yshift=2em, xshift=1em]A.north east) node[above, pos=0.5, yshift=1em, align=center] {Unwrapping \\ E/$\Pi$ phase};
\draw[decoration={brace, amplitude=1em}, decorate]  ([yshift=2em, xshift=-1em]B1.north west) -- ([yshift=2em, xshift=1em]B3.north east) node[above, pos=0.5, yshift=1em] {Simple E/D phase};
\draw[decoration={brace, amplitude=1em}, decorate]  ([yshift=2em, xshift=-1em]C.north west) -- ([yshift=2em, xshift=1em]C.north east) node[above, pos=0.5, yshift=1em, align=center] {Wrapping \\ E/$\Pi$ phase};

\path[->]
(X.east) edge     	node{}    	(A.west)
(A.east) edge     	node{}    	(B1.west)
(B1.east) edge		node{}		(B2.west)
(B2.east) edge		node{}		(B3.west)
(B3.east) edge     	node{}    	(C.west)
(C.east) edge     	node{}    	(Y.west);
\end{tikzpicture}
\centering
\caption{Eviction under the Rebuild method, with encryptions (E) and decryptions (D) and permutations ($\Pi$) and three mixes.} \label{fig:rebuild}
\end{figure*} 

\noindent\textbf{Rebuild method.} The rebuild method aims at replacing all the mix encryption and permutation layers with new ones. The difficulty of this method is to replace the layers in a manner such that the intermediaries never see the underlying client encryption in order to prevent an adversary from observing which record was accessed.
In order to achieve this, the records are encrypted and decrypted in two phases : a simple encryption-decryption (E/D phase) phase and a encryption-permutation (E/$\Pi$ phase) one. Contrary to the Layered method, we encrypt with AES in Counter mode (AES-CTR) and use the record current index as counter.

Before sending the records to the untrusted storage, the client encrypts the plain-text three times. The records are first encrypted with the client own private keys and fixed counters, then with the keys generated from the secrets shared with the mixes and fixed counters. Finally the records are permuted and encrypted at the same time, with the permutation seeds and encryption keys generated from the shared secrets.
For the sake of conciseness, we summarize the state of the database with the status $E_{k0}, (\Pi_\sigma, E_{k1})$ that must be understood as the database was first encrypted with the encryption keys $k0$ and then at the same time permuted and encrypted with the permutation seeds $\sigma$ and the encryption keys $k1$.\\

During the eviction (c.f. Figure~\ref{fig:rebuild}), the mixes first unravel the last layer $(\Pi_\sigma, E_{k1})$ by executing $(\Pi_{\sigma}^{-1}, D(k1))$ during an unwrapping E/$\Pi$ phase. At the end of it, the database is then in the original sequence and encrypted under $E_{k0}$ only. 
The mixes then start E/D phase where the records are encrypted with $E(k_{0i}')$ before being decrypting with $D(k_{0i})$ by each mix $mix_i$ thanks to AES-CTR commutativity and the invariant counter. The database is now in the original sequence and encrypted under $E_{k0'}$ only. Finally, the wrapping E/$\Pi$ phase starts with the mixes encrypting and permuting at the same time the records executing $(\Pi_{\sigma'}, E_{k1})$. The database is now permuted in the random order $\Pi_{\sigma'}$ and encrypted under $E_{k0'}, (\Pi_{\sigma'}, E_{k1'})$.\\  

When retrieving a record, as shown in Alg~\ref{alg:racc}, the client has to compute the record's remote index using the permutation seeds. The client saves all intermediary and final indices and use them as counters to decrypt the record sequentially $r$ times as written in Alg~\ref{alg:rdec}. The client then decrypts the record with all the shared secrets and its own encryption key together with the original index as counter to reveal the plain-text. After updating the cache with the encryption of the record to read or write, the latter is sent back.

\begin{algorithm}
\SetKwComment{Comment}{//}{}
\DontPrintSemicolon
\KwIn{Encryption keys $k_{mix,round}$; \\ \qquad Permutation seeds $\sigma$; \\ \qquad Record and index $record,\ index$;  \\ \qquad Operation and data $op,\ towrite$;  \\ \qquad Number of rounds and mixes $r,\ m$;}
$indices \gets \{\}$;\\
$round\gets \{\}$;\\
\ForAll{$i \in \llbracket 1, r\rrbracket$}
{
$round,\ indices \gets recover\_indices(index,\ r,\ \sigma)$;\\
}
$cache \gets fetch\_cache()$;\\
\If{$record \in cache$}
{
$record \gets find(record)$;\\
$tofetch \gets choose\_dummies(cache, 1)$;\\
}
\Else
{
$tofetch \gets indices[r]$;\\
}
$record, d \gets fetch(tofetch)$;\\
$record \gets \textbf{decrypt}(record,k,\sigma)$;\\
\If {$op==read$}
{
$update\_cache(encrypt(record,k,\sigma))$;\\
}
\Else
{
$update\_cache(encrypt(towrite,k,\sigma))$;\\
}
$send\_cache()$;\\
\KwOut{record}
\caption{Rebuild access method}
\label{alg:racc}
\end{algorithm}

\begin{algorithm}
\SetKwComment{Comment}{//}{}
\DontPrintSemicolon
\KwIn{Record and index $rec,\ index$;\\ \qquad Number of rounds and mixes $r,\ m$; \\ \qquad Encryption keys $k_{mix, round}$; \\ \qquad Mix and Indices $round,\ idx$;}
\ForAll{$i \in \llbracket 1, r\rrbracket$}
{
$mix \gets round[r-i]$
$rec \gets decrypt(rec,\ k_{mix,r-i}, idx[r-i] )$;\\
}
\ForAll{$i \in \llbracket 1, m\rrbracket$}
{
$rec \gets decrypt(rec, k_{i,0}, index )$;\\
}
\KwOut{record}
\caption{Rebuild decryption algorithm}
\label{alg:rdec}
\end{algorithm}
%
\subsection{A simple Mix-ORAM}\label{SMO}
%
We consider here the mix-net in a classic cascade configuration and present two designs with either the use of the layered encryption method or the rebuild method. We also want to remind that we consider the database to always be permuted according to a number of seeds, denoted $\Pi_{\sigma}$, the eviction goal being to obviously sort the database to a new state $\Pi_{\sigma'}$.\\

\noindent\textbf{Layered Cascade.} The design sends the whole database through the mix-net where each mix adds a new permutation and a new encryption layers. Before the randomization starts, the database was permuted with the old seeds $\sigma_i$ and encrypted with the keys $k_i$. After randomization, the database is encrypted with both $k_i$ and $k_i'$ and permuted with both seeds $\sigma_i',\ \sigma_i$, as shown in Fig~\ref{fig:ASMO_L}.\\
%
\begin{figure}[H]
\begin{minipage}{0.475\textwidth}
\begin{adjustbox}{width=\textwidth}
\centering
\begin{tikzpicture}[->, auto, semithick,  node distance = 5.5em]
\tikzstyle{every state}=[fill=white,draw=black,thick,text=black]
\node[draw, cylinder, shape border rotate=90,minimum height=3em,minimum width=2em, label=above:{$k_{i=1..m} $},label=below:{$\sigma_{j=1..m}$}]    	(0)				  {DB};
	
\node[draw, rectangle]   		(A)[right of=0, label=above:{$E(k_1')$},label=below:{$\Pi(\sigma_1')$}]   {\small $Mix_{1}$};

\node[draw=none, fill=none]    		(X)[right of=A]   {\small $...$};

\node[draw, rectangle]    		(B)[right of=X, label=above:{$E(k_m')$},label=below:{$\Pi(\sigma_m')$}]   {\small $Mix_m$};

\node[draw, cylinder, shape border rotate=90,minimum height=3em,minimum width=2em, label=above:{$k_{i=1..m},\ k_{i=1..m}' $},label=below:{$\sigma_{j=1..m},\ \sigma_{j=1..m}'$}]    	(00)[right of=B]				  {DB};	

\path
(0.east) edge     	node[align=center]{}    	(A.west)

(A.east) edge     	node{}    	(X.west)

(X.east) edge     	node{}    	(B.west)

(B.east) edge     	node[align=center]{}    	(00.west)
;

\end{tikzpicture}
\end{adjustbox}
\centering
\caption{Layered simple Mix-ORAM eviction.} \label{fig:ASMO_L}
\end{minipage}
\end{figure} 

\noindent\textit{Mix instructions.}
The client sends to every mix one element of a cyclic group of prime order satisfying the decisional Diffie-Hellman Assumption as in Sphinx~\cite{danezis2009sphinx} $\alpha$ to perform the permutations and to encrypt the records. Alongside this elements, are sent the signed list of mixes $(ports,\ ips)$ and the database access information $db$ consisting of the IP addresses and access token. The client thus send to each mix $mix_i$:
$$ db,\ \alpha_{i},\ (ports,\ ips) $$

Let $g$ be a generator of the prime-order cyclic group $\mathcal{G}$ satisfying the Diffie-Hillman Assumption and $q$ the prime order of $\mathcal{G}$. We assume that each mix $mix_i$ has a public key $y_i=g^{x_i}\in \mathcal{G}^*$ with $x_i \in_{\mathbb{R}} \mathbb{Z_q}$ alongside the presence of a Public Key Infrastructure to distribute an authenticated list of all $(mix_i, y_i)$.
To generate the $\alpha$s, the client pick at random in $\mathbb{Z}_q$ for each mix $mix_i$ the element $z_i$. The group element $\alpha$ and the shared secret $ss$ are generated and the encryption keys and permutation seeds are derived as follows:
\begin{align*}
\alpha_i &= g^{z_i}\ ;\ ss_i = y_i^{z_i}\ ;\ k_i,\ \sigma_i=hkdf(sk_i)
\end{align*}

\noindent\textit{Mix operations.} In this simple scheme, the mix $mix_i$ receives a list of encrypted records from the mix $mix_j$ (or fetch the database if $i=0$). The mix $mix_i$ encrypts the records with the $k_i$ and permutes the records  with the seed $\sigma_{i}$ and sent to $mix_{i+1}$ (or the database if $i=m$).\\

\begin{algorithm}
\SetKwComment{Comment}{//}{}
\DontPrintSemicolon
\KwIn{Database info $db$;\\ \qquad Group elements $\alpha_i$;\\ \qquad List of mixes $list=(ips,\ ports)$;\\ \qquad Private key $x_i$; \\ \qquad Data $data$;}
$k_i,\ \sigma_{i}=hkdf(\alpha_{i}^{x_i})$;\\
$index \gets list.index(mix_i)$;\\
\If{$index==0$}
{
$data \gets fetch\_DB(db)$;\\
}
\ForAll {$d \in data$}
{
	$d \gets encrypt\_cbc(k_i, d)$;\\
}
$data \gets \Pi_{\sigma_i}(data)$
\If{$index !=m$}
{
$data \gets send\_mix(list[index+1], data)$;\\
}
\Else
{
$data \gets send\_DB(db, data)$;\\
}
\caption{Layered Cascade mix operation for mix $mix_i$.}
\label{alg:CL}
\end{algorithm}

\noindent\textit{Client Operations.} To find a record position in the database, the client just needs to look at the current index in the record index.\\

\noindent\textit{Costs.}
As the whole database is sent through the mix-net, the mix communication cost is $ \cdot m \cdot n \cdot b$. The client communication is $m \cdot (32+ m\cdot (ip +ports)+ token)$.
The computation cost for the client is ..., and ... per mix  \todo{}.\\


\noindent\textbf{Rebuild Cascade.} The design refreshes both permutation and AES-CTR encryption. Before the randomization starts, the database was permuted with the old seeds $\sigma_i$ and the records encrypted with the keys $k_i$ and their index as counter. After randomization, the database is permuted with the new seeds $\sigma_i'$ and encrypted with the new keys $k_i'$.
The mixes operates as as depicted in Fig~\ref{fig:ASMO_R}: they first decrypt and unwrap the records, then change the inner encryption by encrypting with the new keys and decrypting with the old, and finally wrap and encrypt again with the new keys.


\begin{figure}[H]
\begin{minipage}{0.475\textwidth}
\begin{adjustbox}{width=\textwidth}
\begin{tikzpicture}[->, auto, semithick, node distance = 5em, every loop/.style={<-}]
\tikzstyle{every state}=[fill=white,draw=black,thick,text=black]


\node[draw, cylinder, shape border rotate=90,minimum height=3em,minimum width=2em, label=above:{\small $k_{i=1..m}$},label=below:{\small $\sigma_{j=1..m}$}]    	(0)				  {DB};

\node[draw=none, fill=none]    		(00)[below of=0]   {};

\node[draw, cylinder, shape border rotate=90,minimum height=3em,minimum width=2em, label=above:{\small $k_{i=1..m}'$},label=below:{\small $\sigma_{j=1..m}'$}]    	(000)	[below of=00]			  {DB};
	
\node[draw, rectangle, label=above:{\small $D(k_1)$},label=below:{\small $\Pi^{-1}(\sigma_1)$}]   		(A)[right =of 0.north east, anchor = north]   {\small $Mix_{1}$};

\node[draw, rectangle, label=above:{\small $E(k_{m+1}')$},label=below:{\small $D(k_{m+1})$}] (A')[below of=A]{\small $Mix_{1}$};

\node[draw, rectangle, label=above:{\small $E(k_m')$},label=below:{\small $\Pi(\sigma_1')$}]   		(A'')[below=of A', anchor = south]   {\small $Mix_{1}$};

\node[draw=none, fill=none]    		(X)[right of=A]   {\small $...$};
\node[draw=none, fill=none]    		(X')[right of=A']   {\small $...$};
\node[draw=none, fill=none]    		(X'')[right of=A'']   {\small $...$};

\node[draw, rectangle, label=above:{\small $E(k_m)$},label=below:{\small $\Pi^{-1}(\sigma_m)$}]    		(B)[right of= X]   {\small $Mix_m$};
\node[draw, rectangle, label=above:{\small $E(k_{2m}')$},label=below:{\small $D(k_{2m})$}]    		(B')[right of=X']   {\small $Mix_{m}$};
\node[draw, rectangle, label=above:{\small $E(k_m')$},label=below:{\small $\Pi(\sigma_m')$}]    		(B'')[right of= X'']   {\small $Mix_m$};

\path 
([yshift=0.47em]0.east) edge    node{}    	(A.west)

(A.east) edge node{}    	(X.west)

(X.east) edge node{}    	(B.west)

(B.east) edge[bend left] node{} ([yshift=1ex]B'.east)

([yshift=1ex]B'.west) edge[align=center] node{} 	([yshift=1ex]X'.east)

([yshift=1ex]X'.west) edge[align=center]  node{}   	([yshift=1ex]A'.east)

([yshift=-1ex]A'.east) edge[align=center] node{} (B''.west)

([yshift=-1ex]B''.west) edge    node{}  ([yshift=-1ex]X''.east)

([yshift=-1ex]X''.west) edge    node{}  ([yshift=-1ex]A''.east)

([yshift=-1ex]A''.west) edge node{} (000.east);


\end{tikzpicture}
\end{adjustbox}
\centering
\caption{Rebuilt simple Mix-ORAM.} \label{fig:ASMO_R}
\end{minipage}
\end{figure} 
%
\noindent\textit{Mix instructions.}
The client sends to every mix two elements of a cyclic group of prime order satisfying the decisional Diffie-Hellman Assumption $\alpha_{old}$ to undo the old permutations and decrypt the old layers, and $\alpha_{new}$ to perform the new ones. Alongside these elements, are sent the signed list of mixes $(ports,\ ips)$ and the database access information $db$ consisting of the IP addresses and access token. The client thus send to each mix $mix_i$:
$$ db,\ \alpha_{i,\ old},\ \alpha_{i,\ new}\ (ports,\ ips) $$

Let $g$ be a generator of the prime-order cyclic group $\mathcal{G}$ satisfying the Diffie-Hillman Assumption and $q$ the prime order of $\mathcal{G}$. We assume that each mix $mix_i$ has a public key $y_i=g^{x_i}\in \mathcal{G}^*$ with $x_i \in_{\mathbb{R}} \mathbb{Z_q}$ alongside the presence of a Public Key Infrastructure to distribute an authenticated list of all $(mix_i, y_i)$.
To generate the $\alpha$s, the client pick at random in $\mathbb{Z}_q$ for each mix $mix_i$ the elements $z_i$ and $z_i'$. The group elements $\alpha$, shared secrets $sk$ and $ss$ are generated and the encryption keys and permutation seeds are derived as follows: $$\alpha_i = g^{z_i},\ sk_i = y_i^{z_i},\ k_i, \sigma_i=hkdf(sk_i)$$


\noindent\textit{Mix operations.} In this scheme, the mix $mix_i$ receives a list of encrypted records from the mix $mix_j$ (or fetch the database if $i=0$). At first, the records are permuted with the old seed $\sigma_{i}$ and encrypted with the key $k_{i}$ and sent to $mix_{i+1}$ (or itself). The mixes then encrypt the record with both the new and old keys and send to the previous mix (or the last if $i=0$). Finally, the records are permuted with $\sigma_{i}'$, encrypted with $k_{i}'$ and sent to $mix_{i-1}$ (or the database if $i=0$).\\

\begin{algorithm}
\SetKwComment{Comment}{//}{}
\DontPrintSemicolon
\KwIn{Database info $db$;\\ \qquad Group elements $\alpha_i,\ \alpha_i'$;\\ \qquad List of mixes $list=(ips,\ ports)$;\\ \qquad Private key $x_i$; \\ \qquad Data and sender $data,\ sender$;\\ \qquad Time $time=0$;}
$\sigma_{i},\ k_{i}=hkdf(\alpha_{i}^{x_i})$;\\
$\sigma_{i}',\ k_{i}'=hkdf(\alpha_{i}'^{x_i})$;\\
$index \gets list.index(mix_i)$;\\
\If{$time==0$}
{
\If{$index==0$}
{
$data \gets fetch\_DB(db)$;\\
}
$data \gets \Pi_{\sigma_{i}}^{-1}(data)$;\\
\ForAll {$d \in \llbracket 1:data\rrbracket$}
{
	$data[d] \gets encrypt\_ctr(k_{i}, d, data[d])$;\\
}
$time \gets 1$;\\
$receiver \gets list[index]$;\\
\If {$index!=m$}
{
$receiver \gets list[index+1]$;\\
}
$send\_mix(receiver, data)$;\\
}
\uElseIf {$time==1$}
{
\ForAll {$d \in \llbracket 1:data\rrbracket$}
{
	$data[d] \gets encrypt\_ctr(k_{i}, d, data[d])$;\\
    $data[d] \gets encrypt\_ctr(k_{i}', d, data[d])$;\\
}
$time \gets 2$;\\
$receiver \gets list[m]$;\\
\If {$index!=1$}
{
$receiver \gets list[index-1]$;\\
}
$send\_mix(receiver, data)$;\\
}
\Else
{
\ForAll {$d \in \llbracket 1:data\rrbracket$}
{
$data[d] \gets encrypt\_ctr(k_{i}', d, data[d])$;\\
}
$data \gets \Pi_{\sigma_{i}'}(data)$;\\
$receiver \gets db$;\\
\If {$index!=1$}
{
$receiver \gets list[index-1]$;\\
}
$send\_mix(receiver, data)$;\\
}
\caption{Rebuild Cascade mix operation for $mix_i$.}
\label{alg:RCmix}
\end{algorithm}

\noindent\textit{Client operations.} When retrieving a record, the user recovers the remote index thanks to the last seeds as depicted in Algorithm~\ref{alg:CRIL} where the last index being the one sought.\\

\begin{algorithm}
\SetKwComment{Comment}{//}{}
\DontPrintSemicolon
\KwIn{Seeds $\sigma$;\\ \qquad Number of records and mixes $n,\ m$;\\ \qquad Record index $index$;}
$mixes \gets \{,\}$;\\
$indices \gets \{,\}$;\\
\ForAll {$i \in \llbracket 1, m \rrbracket$}
{
	$index \gets {\Pi}_{\sigma_i}(n,\ index)$;\\
	$mixes \gets mixes \cup \{i\}$;\\
	$indices \gets \cup \{index\}$
}
\KwOut{$mixes,\ indices$}
\caption{Cascade Rebuild Index Lookup}
\label{alg:CRIL}
\end{algorithm}

\noindent\textit{Costs.}
As the whole database is sent through the mix-net three times, the mix communication cost is $3\cdot m \cdot n \cdot b$. The client communication is $m \cdot (2 \cdot 32+ (m+1)\cdot (ip +ports)+ token)$.
The  computation cost ... \todo{}.\\

\noindent\textbf{Partial Conclusion.} These two designs are not efficient as only a mix work at a time. To increase the mix-net efficiency, we study in the following section parallelization to distributing the workload among mixes.
% 
\subsection{Parallelizing the Eviction process.}\label{Parallel}
In this section, we replace the cascade configuration of the mix-net with a parallel one and simulate random transposition shuffles (RTS) thanks to the use of private and public permutations as shown in Figure~\ref{fig:Par}. We also calculate the number of rounds needed to reach perfect security by presenting firstly the mixing time of $k$-RTS before introducing ORAM assumptions to reduce the expected time to achieve randomness.

During the eviction process, the whole database makes a round trip through the mix-net before being updated back to the database. However, contrary to the cascade case, we assign chunks of the database to each mix: when the eviction starts, each mix fetches its assigned chunk, for instance $mix_i$ fetches the indices in $\llbracket i\cdot n/m : (i+1)n/m \llbracket$. The mixes, after receiving the records, permute them with private permutation seeds and finally send them to the mix-net according to public permutation seeds. At the end of the eviction, the mixes uploads the records back to the database on their assigned indices. During the way in, the mixes cancel the previous permutations done thanks to the old private and public seeds while in the way out they use the new ones. As the database is permuted by chunks, several rounds of permutation are needed to guarantee a shuffle oblivious to the eyes of the adversary.

\begin{algorithm}
\SetKwComment{Comment}{//}{}
\DontPrintSemicolon
\KwIn{Data $data$; \\ \qquad Old and new private seed $\sigma_{i,round},\ \sigma_{i,round}'$}
\If {in}
{
$data \gets \Pi^{-1}_{\sigma_{i,round}}\left ( data \right )$;\\
}
\Else
{
$data \gets \Pi_{\sigma_{i,round}'}\left ( data \right )$;\\
}
\KwOut{$data$}
\caption{Parallel sort for mix $i$ during round $round$.}
\label{alg:PSort}
\end{algorithm}

When retrieving a record, the user recovers the index thanks to the public and private seeds.

\begin{figure*}
\centering
\begin{minipage}[c]{0.475\textwidth}
\begin{tikzpicture}[->,
auto,
semithick, 
scale=0.5,
block/.style={draw, fill=white, rectangle, font=\small}]

\node[block, align=center]							(B)		{$\textbf{Mix}_k$ \\ $ S_{k,r}$};
\node[draw=none, fill=none]    		(X)[above of=B, yshift=-1em]		[rotate=-90]{...};
\node[draw=none, fill=none]    		(Y)[below of=B, yshift=1em]		[rotate=-90]{...};
\node[block, anchor= north, align=center]			(A)[above of=B, yshift=1em]		{$\textbf{Mix}_1$ \\ $ \sigma_{1,r}$};
\node[block, anchor = south, align=center]			(C)[below of=B, yshift=-1em]		{$\textbf{Mix}_m$ \\ $ \sigma_{m,r}$};

\node[block, align=center]							(B')[left of=B, xshift=-5em]		{$\textbf{Mix}_k$ \\ $ \sigma_{k,r-1}$};
\node[draw=none, fill=none]    		(X')[above of=B', yshift=-1em]		[rotate=-90]{...};
\node[draw=none, fill=none]    		(Y')[below of=B', yshift=1em]		[rotate=-90]{...};
\node[block, anchor= north, align=center]			(A')[above of=B', yshift=1em]		{$\textbf{Mix}_1$ \\ $ \sigma_{1,r-1}$};
\node[block, anchor = south, align=center]			(C')[below of=B', yshift=-1em]		{$\textbf{Mix}_m$ \\ $ \sigma_{m,r-1}$};


\node[block, anchor = east, minimum height=12em]		(1)[right of=B, xshift = 3em]		{$\text{DB}_{i}$};


\path[->, midway]
 (A')		edge node[above,yshift=4ex]		{$S_{pub,r}$} 	(A.west)
 (A')		edge node		{} 					(B.west)
 (B')		edge node		{} 					(C.west)
 (B') 		edge node		{} 					(A.west)
 (C') 		edge node		{} 					(A.west)
 (C') 		edge node		{} 					(C.west)

 (A.east) edge node[sloped, above]	{} 	([yshift=-2ex]1.north west)
 (B.east) edge node[sloped, above]	{} 	(1)
 (C.east) edge node[sloped, above]	{} 	([yshift=2ex]1.south west);
 
\end{tikzpicture}
\centering
\caption*{Last rounds of wrapping} \label{fig:WAS}
\end{minipage}
\hfill
\begin{minipage}[c]{0.475\textwidth}
\begin{tikzpicture}[->,
auto,
thin, 
scale=0.5,
block/.style={draw, fill=white, rectangle, font=\small}]


\node[block, anchor = west, minimum height=12em] 		(0)		{$\text{DB}_i$};

\node[block, align=center]							(B)[right of=0, xshift=3em]		{$\textbf{Mix}_k$ \\ $ \sigma_{k,r}^{-1}$};
\node[draw=none, fill=none]    		(X)[above of=B, yshift=-1em]		[rotate=-90]{...};
\node[draw=none, fill=none]    		(Y)[below of=B, yshift=1em]		[rotate=-90]{...};
\node[block, anchor= north, align=center]			(A)[above of=B, yshift=1em]		{$\textbf{Mix}_1$ \\ $ \sigma_{1,r}^{-1}$};
\node[block, anchor = south, align=center]			(C)[below of=B, yshift=-1em]		{$\textbf{Mix}_m$ \\ $ \sigma_{m,r}^{-1}$};

\node[block, align=center]							(B')[right of=B, xshift=5em]		{$\textbf{Mix}_k$ \\ $ \sigma_{k,r-1}^{-1}$};
\node[draw=none, fill=none]    		(X')[above of=B', yshift=-1em]	[rotate=-90]{...};
\node[draw=none, fill=none]    		(Y')[below of=B', yshift=1em]	[rotate=-90]{...};
\node[block, anchor= north, align=center]			(A')[above of=B', yshift=1em]	{$\textbf{Mix}_1$ \\ $ \sigma_{1,r-1}^{-1}$};
\node[block, anchor = south, align=center]			(C')[below of=B', yshift=-1em]	{$\textbf{Mix}_m$ \\ $ \sigma_{m,r-1}^{-1}$};


\path[->, midway]
 ([yshift=-2ex]0.north east) edge node[sloped, above]{} (A.west)
 (0) edge node[sloped, above]{} (B.west)
 ([yshift=2ex]0.south east) edge node[sloped, above]{} (C.west)

 (A.east) edge node[above,yshift=4ex]	{$S_{pub,r}^{-1}$} 	(A')
 (A.east) edge node						{} 					(B')
 (A.east) edge node						{} 					(C')
 (B.east) edge node						{} 					(A')
 (C.east) edge node						{} 					(B')
 (C.east) edge node						{} 					(C');
 
\end{tikzpicture}
\centering
\caption*{First rounds of unwrapping} \label{fig:UAS}
\end{minipage}
\centering
\caption{Wrapping and corresponding unwrapping.}\label{fig:Par}
\end{figure*} 



\begin{algorithm}
\SetKwComment{Comment}{//}{}
\DontPrintSemicolon
\KwIn{Private and public seeds $\sigma_{i,round},\ \sigma_{round}$;\\ \qquad Number of records, mixes and rounds $n,\ m,\ r$;\\ \qquad Record index $index$;}
$mixes \gets \{,\}$;\\
$indices \gets \{,\}$;\\
\ForAll {$i \in \llbracket 1, r \rrbracket$}
{
	$mix \gets \floor{index/m}$;\\
	$mixes \gets mixes \cup \{mix \}$;\\
	$shuffle \gets {\Pi}_{\sigma_{mix,i}}(i\cdot n / m,\ )i+1)\cdot n / m)$;\\
	$index \gets i\cdot n/m + shuffle.index(index)$;\\
	$indices \gets \cup \{index\}$;\\
	$shuffle \gets {\Pi}_{\sigma_{i}(1,n)}$;\\
	$index \gets shuffle.index(index)$;\\
}
\KwOut{$mixes,\ indices$}
\caption{Parallel Index Lookup}
\label{alg:PIL}
\end{algorithm}

%
\subsubsection{$k$-Random Transposition Shuffle.}\label{kRTS}
% Def of RTS. RTS can be broken down in independant rounds which is nice for amortization. RTS can be made oblivious by making the permutations locally. The mixing time for RTS is high, we look at oblivious k-RTS.
Random Transposition Shuffles (RTS) are widely used examples in the study of card shuffling. It consists in a player picking randomly a couple of cards from a same deck, permuting them according to a coin toss and putting them back at the same location.
These steps, usually called a round, are then repeated until the deck of cards has been properly shuffled, i.e. until every card arranging is possible.\\
We can already see why RTS are natural candidates for amortized ORAMs : if they can be broke down in independent rounds which can be spread over several entities and time, so can a randomization process based on them. Furthermore, having the client (player) permuting the data blocks (cards) locally is enough to make RTS oblivious to the eyes of an adversary.
Diaconis in 1986~\cite{aldous1986shuffling} has proved that the RTS mixing time of a deck of $n$ cards is of the order of $n\log(n)$. We thus first look at oblivious $k$-RTS, an RTS where the client picks and transposes locally $k$ distinct cards to make the scheme more efficient. We stress the difference between doing successively $k/2$ transpositions and what we call $k$-RTS: in the first case, an element can be transposed several times in a row which leads to a different probability distribution. The result we present affirms that  $k$-RTS converges to the uniform distribution more rapidly than repeating normal RTS.  

\begin{secthm}
\textbf{Mixing time of $k$-RTS.} A $k$-random permutation shuffle of a $n$ card game reaches the uniform distribution in $\tau$ rounds, such that
$$E(\tau) < \frac{2}{k}\cdot\frac{n^2}{n+1}\cdot \left ( \log(n) + \mathcal{O}(1) \right ) $$
\begin{proof}
The proof can be found in Appendix~\ref{proof:kRTS}.
\end{proof}
\end{secthm}

PRG seeds actually do not ensure strict transpositions between elements but permutations, that is to say the number of transpositions done while using PRG seeds can be greater than the ones we considered. Hence, the uniform distribution is reached even more quickly. We thus consider that an oblivious $k$-RTS implies computation and communication cost of the order of $\mathcal{O} \left(\frac{n}{k}\cdot \log(n)\right)$.\\

When different parties, the $m$ mixes in our case, perform in parallel the $k$-RTS, we can improve by another factor $m$ the eviction computation time. However, as some mixes can have been compromised by the adversary we ask each mix to perform $2 m\log n$ rounds.
%
\subsubsection{Oblivious Merge}\label{OM}
Before the eviction algorithm is run, the database can be divided in two sets of records depending on whether or not they were retrieved by the user. As such, the database can be represented as a simple binary array of $n$ bits out of which $s$ are 1s, the accessed ones, and $n-s$ are 0s, the others.
We argue that in this representation, elements of the same sets are indistinguishable to the adversary thanks to prior encryptions and permutations and thus, less rounds are necessary to correctly shuffle the database.\\

Indeed, this assumption significantly reduces the number of possible orderings in the adversarial view. We can prove, thanks to the Bars and Stripes theorem, that there now are ${n \choose s}$ orderings instead of $n!$.

We now consider the RTS process in that scenario and suppose the records (the bits) are re-encrypted before being permuting such that the merge of the two sets is oblivious to the adversary.

\begin{secthm}
An oblivious merge (OM) of 2 indistinguishable sets of respective size $n$ and $s$ elements requires $\tau$ rounds of 2-RTS such that any arranging is possible, with
$$\tau(\epsilon) \leq \frac{n}{2}  \cdot \left [ \left( \log \left (\frac{n}{s}-0.5\right) +\mathcal{O}\left(1\right) \right ) - \frac{2}{s} \log \left( 4 \cdot \epsilon\right) \right ] $$%&\\
\begin{proof}
The proof can be found in Appendix~\ref{proof:OM}.
\end{proof}
\end{secthm}

\begin{seccjt}\label{sec:kOM}
A $k$-oblivious Merge ($k$-OM) of 2 indistinguishable sets of respective size $n$ and $s$ requires $\tau$ rounds doing of $k$-RTS such that any arranging is possible, with
$$ \tau(\epsilon) \leq \frac{n}{2\cdot k}  \cdot \left [ \left( \log \left (\frac{n}{s}-0.5\right) +\mathcal{O}\left(1\right) \right ) - \frac{2}{s} \log \left( 4 \cdot \epsilon\right) \right ] $$
\begin{proof}
We could see that permuting $k$ elements in RTS decreased the mixing time by at least a factor $k$, and does so independently of the items to shuffle. Thereby the decrease should still be relevant here.
\end{proof}
\end{seccjt}
%
\subsection{Parallel Mix-ORAM}\label{parallelMixORAM}
%
We now consider the mix-net as a collection of isolated mixes. The unwrapping and wrapping phases consist of $r= \frac{m}{2} \cdot \log \left (\frac{n}{s} \right ) $ rounds as depicted in Fig~\ref{fig:Par}.\\


\noindent\textbf{Layered method.} In that scenario, the mixes keep encrypting the records with the appended IVs and keep permuting them. As the permutation is not undone at any moment, the assumption that the records are indistinguishable holds. Thus we can permute the records the number of times detailed in the oblivious merge method. \\

\noindent\textbf{Message Format.}
The client only need to send to each mix the signed message containing session keys to access the database $(id,\ token)$, information to compute which records it has been attributed $(index,\ range)$, the client's secret used to compute the shared secret $(\alpha_i,\ \alpha_i',\ \alpha_{pub},\ \alpha_{pub}')$, the number of rounds $r$, and the signed ordered $list=(ports,\ ips)$ of the mixes participating in the eviction.
The message format is then : $$db,\ \alpha_i,\ \alpha_i',\ \alpha_{pub},\ \alpha_{pub}',\ n,\ r,\ list$$

\noindent\textbf{Costs.} For 128-bit security, group elements can be expressed in just 32 bytes, we have thus a maximum message size of $|addr|+XXX + 3 \cdot 8 \cdot 32 + XXX$. We have $c_{cmp} = 2\cdot r \cdot n \cdot c_{CBC}$, $c_{client}= x$, $c_{mix}= 2\cdot r \cdot n$ and $c_{com} = 2 \cdot r \cdot n+ c_{client}$.\\

\noindent\textbf{Rebuild method.}
When performing an eviction, the client assigns to each mix  $k=\frac{n}{m}$ distinct indexes together with a list of shared secrets from which will be derive public and private permutation seeds and encryption keys.\\
At first, the mixes fetch their allocated records from the database. They then unwrap the previous permutation: the last wrapping permutations are undone in reverse order thanks to the old private seeds and the records are decrypted with the old encryption keys before being distributed to all mixes according to the inverse permutation of the old public seeds. Then starts the wrapping, where the records are permuted according to the new seeds, encrypted with the new encryption keys and distributed to the mixes according to the new public seeds. Between the wrapping and unwrapping phases, the mixes exchanged in a cascade fashion their records and encrypt them with both the new and old key.\\

\noindent\textbf{Message Format.}
The client send the same data as in the AES-CBC case. The message format is then : $$db,\  \alpha_i,\ \alpha_i',\ \alpha_{pub},\ \alpha_{pub}',\ n,\ r,\ list$$

\noindent\textbf{Costs.} For 128-bit security, group elements can be expressed in just 32 bytes, we have thus a maximum message size of $|addr|+XXX + 3 \cdot 8 \cdot 32 + XXX$. We have $c_{cmp} = 2\cdot (r+m) \cdot c_{CTR} $, $c_{client}=x$, $c_{mix}= (2r+m)\cdot n$. The total communication cost is $c_{com}= (2r+m)\cdot n + c_{client}$.

\section{Security Proof}\label{Security}

We first remark that all of the eviction metadata is independent of data content, it is entirely determined by the sole parameter $n$ and is the same for any access. The data content is also never revealed to the adversary and is refreshed upon reception by every mix.
We argue that the adversary can win the game in only two ways: decrypting the records or finding out the record order before eviction. 

\subsection{In Search of the Lost Order.}
The client has sent to each mix private, and potentially public, group elements chosen as random from which the permutation keys are retrieved. The randomness of the seeds was increased thanks to the use of a key derivation function.\\

\noindent\textbf{Cascade mixnet.}
In this architecture, the whole database is sent from a mix to another. To know the index of any block, the adversary needs to retrieve the group elements sent to the uncompromised mixes. \\

\noindent\textbf{Parallel mixnet.}
In this architecture, chunks of the database are exchanged between mixes. The adversary can benefit of it as some records may never go to uncompromised mixes.\\
Goodrich in 2012 ~\cite{goodrich2012anonymous}, proved the security of such scheme using the sum of squares metric. If we note by $p(i,t)$ the probability the adversary thinks that the a particular card is at index $i$ at round $t$, $m-m_a$ the number of uncorrupted server(s) and by $\Phi(t)= \sum_{i}^{n}\left (p(i,t) - 1/n \right)^2$ the sum of squares metric, we have that $$E[\Phi(t)] = \left (1 - (m-m_a) \cdot \frac{k-1}{n-1}\right )^{t}$$\\
To have $\Phi(t) \leq n^{-c}$ with $m-m_a=1$, we need $cm \log n \leq r \leq 2cm \log(n)$, the upper bound being the value we propose in Section~\ref{kRTS}. The value we propose in Theorem~\ref{sec:kOM}, $\frac{m}{2} \cdot log\left ( \frac{n}{s} \right )$, accounts for the indistinguishability assumption we made: we do not want to hide the position of every record, only the position of $s$ of them (the accessed ones). ?

\subsection{In Search of the Lost Key.}
We assume here the adversary knows the invariant position of some of the records he asked the user to query. 

\noindent\textbf{The CBC case.}
In the CBC case, the blocks and IVs are encrypted again and again with AES in CBC mode. If a block was accessed, it is however encrypted only once by the user before the eviction.\\

\noindent\textbf{The CTR case.}
In the case of CTR, the adversary only needs to discover the uncompromised mixes' bindings. 

uncompromised mix blindings are never known by the adversary as the records are encrypted with AES-CTR when being (un)blinded. Thereby, the records after the unwrapping are undistinguishable from random arrays, and the adversary cannot see which records were accessed.

\section{Evaluation}\label{Evaluation}
\textbf{Layered method.} We now look at the average number of encryption layers a record has before being decrypted. Making the assumption that the record access distribution is uniform, we can represent the problem of accessing all records at least once as a coupon collector problem. In that case, we expect $E[e]\leq(n/s)\cdot H_n )$ evictions before all records have been fetched once with $H_n$ the $n^{th}$ harmonic number, and the expected number of layers per card is $E[r]\leq{r/s} \cdot \left ( \frac{n+1}{2}\cdot(H_n-1/2)+1/2 \right )$. For $n=10^6$ and $s=\sqrt{n}$, we have $E[e]\approx 15 \cdot 10^3$ and $E[r]\approx 7\cdot 10^3 \cdot r$.
\begin{proof}
Lets $\tau_n$ be the random number of coupons collected when the first set contains every $n$ types. We have, $E[\tau_n]=n\sum_{i=1}^n \frac{1}{i} = n \cdot H_n$.
Since we fetch $s$ unique records per eviction (we cannot fetch a record already in the stash), the previous result is an upper bound of the number of requests needed and so the expected number of eviction is $E[e]\leq n/s\ H_n$.

We now want to find the average number of encryption layers per record before decryption, this is equivalent to finding the average number of evictions before a record is deciphered. 
Hence we have, $E[r]\leq r/s \cdot \sum_{i=1}^n E[\tau_i] = r/s\ \sum_{i=1}^n \left (\frac{(n+1-i)(n+i)}{2}\cdot \frac{1}{i}\right )$ from which can be calculated the result presented earlier. 
\end{proof}

To reduce these numbers, we modify the access method as written in Algorithm~\ref{alg:lacc}. When the client requests a record from the database, $d$ other records are chosen uniformly at random from the set of unaccessed records. These records are then fetched, their encryption is refreshed as written previously and the client overwrites with these records their older version on the database. Doing so, choosing a parameter $d$ high enough yields a better approximation of the uniform distribution assumption. We would have thus $E[e]\leq n/(sd) \cdot H_n $ and $E[r] \leq{r/(sd)} \cdot \left [ \frac{n+1}{2}\cdot(H_n-1/2)+1/2 \right ] \ H_n$.
With $d=\sqrt(n)$, we now have $E[e]\leq 15$ and $E[r]\leq 7$.
\subsection{Implementation and Benchmark}\label{Implementation}
\subsection{Performances}\label{Performance}
performance per enc, performance per design, performance with implementation
\subsection{Comparison}\label{Comparison}
Comparison of our schemes

\begin{table*}
\begin{minipage}[t][][b]{.475\textwidth}
\vspace{0pt}
\centering
\begin{tabular}{*4c}
\toprule
    				& $C_{comp}$  	 & $C_{comm}$		& $C_{access}$\\
\midrule
Cascade - CBC   &  17.5 		& 19.1   		& 17.5  \\
Cascade - CTR   &  11.8 		& 12.7   		& 29.3  \\
Parallel - CBC  &  6.6  		&  5.6   		& 35.9  \\
Parallel - CTR  &  6.6  		&  5.6   		& 35.9  \\
\bottomrule
\end{tabular}
\centering
\caption{Cost comparison of designs.}
\end{minipage}
\hfill
\begin{minipage}[t][][b]{.475\textwidth}
\vspace{0pt}
\begin{tabular}{*4c}
\toprule
    				& $m=3$  	 & $m=5$		& $m=7$\\
\midrule
Cascade - CBC   &  17.5 		& 19.1   		& 17.5  \\
Cascade - CTR   &  11.8 		& 12.7   		& 29.3  \\
Parallel - CBC  &  6.6  		&  5.6   		& 35.9  \\
Parallel - CTR  &  6.6  		&  5.6   		& 35.9  \\
\bottomrule
\end{tabular}
\centering
\caption{Time comparison of designs,\\with $n=\frac{1024^3}{4\cdot 1024}$, $s=\sqrt n$.}
\end{minipage}
\end{table*}


\section{Discussion}\label{Discussion}

\subsection{Active Adversary}\label{Active Adversary}
As misbehaving mixes are already discarded in the eviction setup, we could integrate in the client a light-weight local mix reputation system based on Randomized Partial Checking.


\section{Acknowledgement}
Danezis was supported by H2020  PANORAMIX Grant (ref. 653497) and EPSRC Grant EP/M013286/1; and Toledo by Microsoft Research.


\section{Conclusion}\label{Conclusion}
\begin{itemize}
 \item New ORAM with mix-net
 \item amortizable eviction
 \item can fetch while eviction running
 \item multi-user friendly as all the secrets are on the server
\end{itemize}

\bibliography{mix_oram}
\bibliographystyle{splncs03}

\section{Appendix}
\subsection{Proof $k$-RTS}\label{proof:kRTS}
\begin{proof}
To first prove the upper bound and variance, we use Diaconis et al. results~\cite{aldous1986shuffling} which states that $\tau$ defined in the following game is a strong stationary time.
In a random transposition shuffle, the cards chosen by the right and left hands at time $t$ are respectively called $R_t$ and $L_t$. Assuming that when $t=0$, no card is marked, we mark $R_t$ if
$R_t$ was unmarked before and either $L_t$ is marked or $L_t = R_t$. The variable $\tau$ represents the time when every card has been marked, we call it the stopping time.

Let be $\tau_t$ the number of transpositions after the $t^{th}$ card is marked, up to and including when the $(t+1)^{th}$ is marked. $$\tau = \sum_{i=0}^{n-1} \tau_i$$
The $\tau_t$ are independent geometric variables with probability of success $p_t$ as implied by the game rules.
The probability of success corresponds to the probability of marking at least one card, one to $t$ cards exactly. To do so, the right cards must be chosen from the unmarked set, comprising $n-t$ cards at time $t$,
and the left cards from the union of the marked set and the right cards.
\begin{align*}
 p_t &= \sum_{i=1}^{min(k,n-t)} {k \choose i} \cdot {t+1 \choose i} \cdot {n-t \choose i}\cdot{n \choose i}^{-2}&\\
 &= \frac{1}{n^2} \cdot \left ( k \cdot (t+1)\cdot(n-t) + \alpha_{n,t,k}\right ),\ 0 < \alpha_{n,t,k} = \mathcal{O}\left(n^{-k}\right )
\end{align*}

We can thus rewrite $\tau$'s expectation as following.
\begin{align*}
 E(\tau) &= \sum_{t=0}^{n-1} \frac{1}{p_{t}} = \sum_{t=0}^{n-1} \frac{n^2}{k \cdot (t+1)\cdot(n-t) + \alpha_{n,t,k}}&\\
 &< \sum_{t=0}^{n-1} \frac{n^2}{k \cdot (t+1)\cdot(n-t)}  &\\
 &< \frac{1}{k} \cdot \frac{n^2}{n+1} \cdot  \sum_{t=0}^{n-1} \left ( \frac{1}{t+1} + \frac{1}{n-t} \right ) &\\
% &< \frac{2}{k} \cdot \frac{n^2}{n+1} \cdot H_n  \\
 &< \frac{2}{k} \cdot \frac{n^2}{n+1} \cdot \left( \ln(n) + \gamma +\mathcal{O}(\frac{1}{n}) \right), \gamma = \lim_{n \to \infty} H_n - \ln(n)& \\
 \end{align*}
 \begin{align*}
 var(\tau) &= \sum_{t=0}^{n-1}\frac{1-p_t}{{p_t}^2}\ <\  \sum_{t=0}^{n-1}\frac{1}{{p_t}^2} &\\
 &< \sum_{t=0}^{n-1}\frac{1}{\left ( k \frac{(t+1)\cdot(n-t)}{n^2} + \alpha_{n,t,k}\right )^2}\\\
 &<\ \sum_{t=0}^{n-1} \frac{1 }{\left ( k \frac{(t+1)\cdot(n-t)}{n^2} \right )^2} &\\
 %&< \frac{n^4}{k^2} \left ( \sum_{t=0}^{\frac{n}{2}-1} \frac{1}{\left ( (t+1)(n-t)\right )^2}  + \sum_{t=\frac{n}{2}}^{n-1} \frac{1}{\left ( (t+1)(n-t)\right )^2} \right ) &\\
 &< 2 \cdot \left (\frac{n}{k} \right )^2 \cdot \left (\frac{n}{n/2} \right )^2 \cdot \sum_{t=0}^{n/2-1} \frac{1}{(t+1)^2} &\\
 &< \frac{4}{3} \pi^2 \cdot \left (\frac{n}{k} \right )^2 
\end{align*}
\\

To now prove the lower bound of $\tau$, we will compare the number of fixed points of a permutation $\sigma$, $F(\sigma)$, for our shuffle, the permutation
obtained from the identity by applying $kt$ random transpositions $ P^{kt}(id, \cdot)$, and the uniform distribution $\pi$, or more precisely compare the corresponding probabilities over the set $A=\{\sigma : F(\sigma) \geq \frac{\mu}{2} \}$.
We can say that after $t$ shuffles, the number of untouched cards of our shuffle has the same distribution as the number $R_{2kt}$ of uncollected coupon types after $2kt$ steps of a coupon collector chain
and that about $ P^{kt}(id, \cdot)$ that the associate $F(\sigma)$ is at least as large as the number of cards that were touched by none of the transpositions, i.e. $P^{kt}(id,A) \geq P(R_{kt}\geq A) $.

We know that the $R_{2kt}$ has expectation $\mu = np$  with $p=\left ( 1 - \frac{1}{n} \right )^{2kt}$, variance $var = np(1-p) <\mu$ and by Chebyshev, we know that $\Pr(R_{2kt}\leq \frac{\mu}{2})\leq \frac{4}{\mu}$
as $\Pr(|R_{2kt} - \mu|\geq \frac{\mu}{2}) = \Pr(R_{2kt} \geq \frac{3\mu}{2}) + \Pr(R_{2kt} \leq \frac{\mu}{2}) > \Pr(R_{2kt} \leq \frac{\mu}{2})$.\\

By Markov's inequality we know that $\pi(A) \leq \frac{2}{\mu}$.\\

As $P^{kt}(id,A) \geq P(R_{kt}\geq A) $, we also have $P^{kt}(id,A^c) \leq P(R_{2kt}\leq A) \leq \frac{4}{\mu} $ which leads to $P^{kt}(id,A)\geq1 - \frac{4}{\mu}$.\\

Thus we have $d(t)=||P^{kt}(id,) - \pi ||_{TV} \geq |1 - \frac{4}{\mu} - \frac{2}{\mu}| \geq 1 - \frac{6}{\mu}$.\\

We want to find the minimum $t$ such that $1-\frac{6}{\mu}\geq \epsilon$, which is equivalent to $n \cdot \left ( 1 - \frac{1}{n} \right )^{2kt} \geq \frac{6}{1-\epsilon}$ and to
$$\log\left(\frac{n\cdot (1-\epsilon)}{6}\right) \geq 2\cdot k\cdot t \cdot \log \left ( \frac{n}{n-1} \right )$$
As $\log(1+x) \leq x$, the previous inequality holds if $\log\left(\frac{n\cdot (1-\epsilon)}{6}\right) \geq   \frac{2kt}{n-1} $ which means that if $t\leq \frac{n-1}{2k}\cdot \log\left ( \frac{n(1-\epsilon)}{6}\right )$ then $d(t)\geq \epsilon$.
Thus,
$$\tau \left (\epsilon \right ) \geq \frac{n-1}{2k} \ln(n\cdot \frac{1-\epsilon}{6}) $$.
\end{proof}

\subsection{Proof of Oblivious Merge}\label{proof:OM}
\begin{proof}
We want to find the mixing time $\tau(\epsilon)$ of our oblivious merge of two sets of indistinguishable elements. To do so, we use the bound of the mixing time of an irreducible ergodic Markov Chain, where $p = \frac{1}{|V|}$ and $1-\lambda^*$ is the spectral gap,
$$\frac{\lambda^*}{1-\lambda^*} \cdot \log\left(\frac{1}{2 \epsilon} \right)\leq \tau(\epsilon) \leq \frac{1}{1-\lambda^*}\cdot \log \left( \frac{1}{2 \epsilon \cdot \sqrt{p}}\right) $$

We now want to find a bound for $\lambda^*$. We represent the arranging of merge of the 2 distinct sets by the graph $\mathcal{G}$, a $k$-regular graph with $v$ vertices corresponding to the different orderings and the undirected edges to transpositions of two elements.
By definition, the eigenvalues of the transition matrix of the $\mathcal{G}$ are $k={\lambda'}_0 > {\lambda'}_1 \geq  ... \geq {\lambda'}_{n-1}$, and we have,
$$\text{diam}\left( \mathcal{G}\right) \leq \frac{log(v-1)}{log(\frac{k}{{\lambda'}^*})}+1 \text{ with } {\lambda'}^* = max_{i\neq0}({\lambda'}_i)= k \cdot \lambda^*$$
with $diam\left( \mathcal{G} \right)=s$ the diameter of the graph, $v= {n \choose s}$ the number of vertices and $k=s\cdot(n-s)$.\\


We can thus find a first relation:
\begin{align*}
log(\frac{k}{{\lambda'}^*}) &= log(\frac{1}{{\lambda}^*}) \leq\frac{\log(v-1)}{\text{diam}\left(\mathcal{G}\right)-1}&\\
log({{\lambda}^*}) &\geq  \frac{log(v-1)}{1-\text{diam}\left(\mathcal{G}\right)}&\\
{\lambda}^* &\geq (v-1)^{\frac{-1}{\text{diam}\left(\mathcal{G}\right)-1}}\\
{\lambda}^* &\geq \left ({n \choose s}-1 \right )^{\frac{1}{1-s}} \geq \left (\frac{n\cdot e}{s} \right )^{\frac{s}{1-s}}
\end{align*}

And can derive the minimum value of $\Delta=\frac{\lambda^*}{1-\lambda^*}$,
\begin{align*}
 \Delta &= \frac{1}{\left (\lambda^*\right )^{-1}-1}\\
 &\geq \frac{1}{\left (\frac{n \cdot e }{s} \right )^{\frac{s}{s-1}}-1}\\
\end{align*}


To find an upper-bound of $\lambda^*$, we will focus on the spectral gap bounding.
Let's $\mathcal{G}_{0,1}=\{0,1\}^n$ be the group of elements with the XOR operation and $\mathcal{S}=\{x \in \mathcal{G},\ weight(x)=s\}$ the symmetric subset of $\mathcal{G}$ of n-binary array with $s$ 1s and $n-s$ 0s.
We call $Cay_{n,s}=Graph\left(  \mathcal{G}_{0,1}, \mathcal{S} \right) $ the Cayley graph generated from these structures.

\begin{lemma}
Let $\mathcal{G}$ be a finite Abelian group, $\chi\ :\  \mathcal{G} \rightarrow \mathbb{C}$ be a character of $\mathcal{G}$, $\mathcal{S} \subseteq \mathcal{G}$ be a symmetric set.
Let $M$ be the normalized adjacency matrix of the Cayley graph $G = Cay(\mathcal{G},\mathcal{S})$.
Consider the vector $x \in \mathbb{C}^\mathcal{G}$ such that $x_a = \chi(a)$. Then x is an eigenvector of $G$, with eigenvalue $$ \frac{1}{\mathcal{S}} \sum_{s\in \mathcal{S}} \chi\left(s\right)$$
\end{lemma}

\begin{theorem}
The Cayley graph $Cay_{n,s}$ has for eigenvalues $\mu_0 = 1 > \mu_1 \geq ... \geq \mu_n$ with, 
$$\mu_r = \frac{1}{\left | \mathcal{S} \right |} \sum_{i=1}^{min(r, n-r)} \left ( -1 \right )^i {r \choose i}{n-r \choose s-i}\\$$
\end{theorem}

\begin{subproof}
$\forall r \in \{0,1\}^n$, with $\chi_r(x)=\left ( -1 \right )^{\sum r_i \cdot x_i}$, we have,
\begin{align*}
\mu_r &= \frac{1}{\mathcal{S}} \sum_{s\in \mathcal{S}} \chi\left(s\right) \\
&= \frac{1}{\left | \mathcal{S} \right |} \sum_{s\in \mathcal{S}} \left ( -1 \right )^{\sum r_i \cdot s_i} \\
&=  \frac{1}{\left | \mathcal{S} \right |} \left ( \left | ``1" \right | - \left | ``-1"  \right| \right ) \\
&= \frac{1}{\left | \mathcal{S} \right |} \sum_{i=1}^{min(r, s)} \left ( -1 \right )^i {r \choose i}{n-r \choose s-i} \\
&= 1 - \frac{2}{{n \choose s}} \cdot \sum_{i=0}^{min(\frac{r-1}{2}, \frac{s-1}{2})} {r \choose 1+2i}{n-r \choose s-2i-1} \\
&= \frac{{n-r \choose s}}{{n \choose s}} \ _2F_1(-r,-s,n-2r+1,-1)
%&= \frac{1}{\left | \mathcal{S} \right |} \left [ \sum_{i=0}^{min(\frac{r}{2},\frac{n-r}{2})} {r \choose 2i}{n-r \choose s-2i} - \sum_{i=0}^{min(\frac{r-1}{2}, \frac{n-r-1}{2})} {r \choose 1+2i}{n-r \choose s-2i-1}\right] 
\end{align*}
\end{subproof}


Remark. We recognize here the Vandermonde identity with alternating numbers. We argue that the eigenvalues of the Cayley graph $Cay_{n,s}$ are all positive as the smallest eigenvalue is null.
For $r=n-r$, the expression simplifies to $\mu_r = {r \choose \frac{n}{2}}$ if $n$ even, 0 otherwise.
For $r=1$, the expression simplifies to $\mu_1 = 1 - 2\cdot \frac{s}{n}$, the spectral gap of $Cay_{n,s}$ is thus equal to $2\cdot \frac{s}{n}$.\\\

We notice that the first graph $\mathcal{G}$ actually is a sub-graph of $Cay_{n,s}$ and as such the the adjacent matrix of the first graph is included in the second's.
For $s>1$, $Cay_{n,s}$ is divided in two sub-graphs representing the cosets of $\{0,1\}^n$ as $\mathcal{S}$ is not a generating group of $\mathcal{G}_{0,1}$, $\mathcal{G}$ is only contained in one of the sub-graphs.
We use the Cauchy's Interlace Theorem to bound the eigenvalues of $\mathcal{G}$ with the ones of $Cay_{n,s}$,.

\begin{theorem}
Let $M$ be a Hermitian $n \times n$ matrix with eigenvalues ${\mu'}_0\geq ... \geq {\mu'}_{n-1}$ and $N$ a $m \times m$ sub-matrix of $M$ with eigenvalues ${\lambda'}_0\geq ... \geq {\lambda'}_{m-1}$ , we have
$$ {\mu'}_i \geq {\lambda'}_i \geq {\mu'}_{n-m+i+1} $$
\end{theorem}

We are here only interested in an upper-bound of $\lambda*$, as we have $\mu_{2^n+2-{n \choose s}}\leq \lambda_1\leq 1-2\frac{s}{n}$ and $0 \leq \lambda_n \leq \mu_2$, $\lambda* \leq 1-2\frac{s}{n}$. We thus have $\frac{1}{1-\lambda*}\leq\frac{n}{2\cdot s}$
\end{proof}

\subsection{Proof of Fake access}
\begin{proof}
 We want to prove that the average number of fake access is 0 in case of a uniform distribution. To do so, we consider the Markov chain and its Transition Matrix.
 The transition matrix $P$ represents the $s$ transient state, in which the stash is not completely filled, and the absorption state in which the stash is full.
Thus, $P$ can be decomposed in 4 sub-matrices: the square sub-matrix $Q_s$ representing all the transient state, the column matrix R with the probabilities of transitioning to the absorbing state, the null row matrix and the absorption matrix.
\[
\begin{bmatrix}
   Q_s & R \\
   0_{1\times s}   & I_1 \\
\end{bmatrix}
\]
To find the average number of steps from one state to the absorbing one, we have solve the following equation, each row corresponding to the average number of steps from the corresponding state (the stashed filled with some records) to the state where the stash is full.
\begin{align*}
 t &= \left (\sum_{k=0}^{\infty} {Q_s}^k \right ) 1 \\
   &= (I_s -Q_s )^{-1} 1
\end{align*}
This equation has a solution since $M=I_s -Q_s$ have independent rows and thus an inverse that we call $N$.
By calculus we find that,
\begin{align*}
 n_{i,j} &= 0 &\text{ if } i>j,\\ 
 n_{i,j} &= \frac{1}{m_{i,i}} &\text{ if } i=j,\\
 n_{i,j} &= - n_{i+1,j } \cdot \frac{m_{i,i+1}}{m_{i,i}} &\text{ if } i<j 
\end{align*}
which can be simplified by
\begin{align*}
 n_{i,j} &= 0 &\text{ if } i>j,\\ 
 n_{i,j} &= \frac{1}{m_{j,j}} \prod_{k=1}^{j-1} \left ( - \frac{m_{i,k+1}}{m_{k,k}}\right ) &\text{ if } i\leq j
\end{align*}
We only want to calculate the first solution $S_1$ from the equation.
\begin{align*}
 S_1 &= \sum_{j=0}^{s-1} \frac{1}{m_{j,j}} \prod_{k=1}^{j-1} \left ( - \frac{m_{i,k+1}}{m_{k,k}}\right ) \\
     &= \sum_{j=1}^{s-1} \frac{1}{m_{j,j}} \text{ as } m_{i,k+1}= -m_{k,k} \\
     &= \sum_{j=0}^{s-1} \frac{1}{1-\frac{j}{n}} = \sum_{j=0}^{s-1} \left (1 + \frac{j}{n-j} \right ) \\
     &= s + \sum_{j=0}^{s-1} \frac{j}{n-j} \\   
\end{align*}
As $s$ steps are required to fill the stash, we thus find the following inequality for the number of fake access $f$:
$$ \frac{s \cdot (s+1)}{2 \cdot n} < f < \frac{s \cdot (s+1)}{2 \cdot (n+1-s)} $$
\end{proof}
\end{document}
