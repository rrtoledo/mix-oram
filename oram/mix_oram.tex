\documentclass{llncs}

\usepackage{etex}
\usepackage{amsmath}
\let\proof\relax
\let\endproof\relax
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{stmaryrd}
\usepackage[justification=centering]{caption}
\usepackage[justification=centering]{subcaption}
\captionsetup{compatibility=false}
\usepackage{float}
\usepackage{tikz}
\usetikzlibrary{shapes, positioning}
\usepackage{adjustbox}
\usepackage[ruled,algosection,noend,linesnumbered]{algorithm2e}
\usepackage{array}
\usepackage{booktabs}
\setlength{\heavyrulewidth}{1.5pt}
\setlength{\abovetopsep}{4pt}

\newtheorem{privdef}{Privacy Definition}
\newtheorem*{secgme}{Security Game}
\newtheorem{secthm}{Security Theorem}
\newtheorem{seccjt}{Security Conjecture}
\newtheorem{seclem}{Security Lemma}

\newenvironment{subproof}[1][\proofname]{%
  \renewcommand{\qedsymbol}{$\blacksquare$}%
  \begin{proof}[#1]%
}{%
  \end{proof}%
}

\newcommand{\raphael}[1]{\textcolor{blue}{Raphael: #1}}
\newcommand{\george}[1]{\textcolor{green}{George: #1}}
\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}
\newcommand{\squeezeup}{\vspace{-0.25cm}}

\begin{document}

\title{Mix-ORAM: Towards a delegated shuffle}
%
\titlerunning{Mix-ORAM}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{Raphael R. Toledo\inst{1} \and George Danezis\inst{1}}
%
\authorrunning{Raphael R. Toledo et al.} % abbreviated author list (for running head)
%
%
\institute{University College London, United Kingdom,\\
\email{r.toledo@cs.ucl.ac.uk}, \email{g.danezis@ucl.ac.uk}}

\maketitle              % typeset the title of the contribution

\begin{abstract}
Oblivious RAM is a key technology for securely storing data on untrusted storage but is commonly considered impractical due to its high overhead. We propose in this paper to  alleviate most of the client computation by delegating the randomization process to semi-trusted third parties.
\keywords{privacy, mix-net, ORAM}
\end{abstract}
%
\section{Introduction}\label{Introduction}
%
The cloud provides a range of services including website hosting, computation, and data storage. In the last case, data integrity must be preserved and the content hidden not only from external adversaries but also from the cloud itself.
Cryptography is thereby used for secure communication channels, user authentication, data encryption and integrity checking.
These, however, do not prevent the leakage of metadata: the storage server owner can watch which records were fetched and deduce from it the data content and the user activities. 

Oblivious RAM (ORAM)~\cite{goldreich87}, or Oblivious Storage (OS)~\cite{boneh2011}, precisely prevents an adversary from observing the real record access. In these schemes, the remote records are permuted in a certain order, and the matching between remote and local indices is saved locally. When the user requests a particular record, the local client  computes its remote index and fetch the corresponding block. After a number of accesses, the database is then reencrypted and shuffle.\\ 
We argue that this randomization process, also called eviction, is the main bottleneck of ORAM. Indeed, every record must be reencrypted and permuted locally, whereas the client memory may be greatly lesser than the cloud's. That is why, we propose here to delegate the eviction to a semi trusted third party without relying on any specific ORAM server design.\\
Mix networks is a solution widely applied in anonymity system to obliviously shuffle packets. A batch of packets is received by the mix-net where it is re-encrypted, or decrypted, and shuffled by each mix such that the output of one mix is the next ones' input. For the adversary to link the input and output, all of the mixes used in the shuffling have to be compromised.
Mix-nets inspired designs could thus address ORAM constraints but at high cost since the re-encryption cost is linear in the number of mixes. If using those designs, methods to amortize the eviction must be taken into account to make ORAM practical.\\

In this work, we present several designs inspired by mixnets for the eviction algorithm.
The advantages of such practices are the delegation of the shuffling, the possibility to delay the latter to quieter times and the independence from centralized parties.

\begin{itemize}
 \item We present the first ORAM eviction relying on a mix-net.
 \item We give a new security definition of ORAM's eviction. %indistiguishability between accessed and unretrieved elements
\end{itemize}

We present the related work, the ORAM model, its associated threat model and explaining the different costs in Section~\ref{Related} and ~\ref{Prelim}, we introduce Random Transposition Shuffles, how to use them in ORAM and together with a mixnet and discuss various optimizations in Section~\ref{Mix-ORAM}. We then present our implementation and compare the costs with several designs in Section~\ref{Evaluation}.
We finally evaluate our schemes with standard ORAM model and discuss about the advantages and drawbacks of using mix-nets.\todo{in the end}
%

\section{Related Work}\label{Related}
\noindent\textbf{ORAM.}
ORAM technologies were first presented by Goldreich and Ostrovsky in 1990~\cite{ostrovsky1990efficient} to prevent reverse engineering and protect softwares thanks to shielded CPU.
Since then, several types of enhancement have been proposed including data structures~\cite{goldreich1996software,stefanov2011towards,stefanov2013path,ren2014ring} with trees, partitions and hierarchichal solutions,
security definitions with statistical security~\cite{damgaard2011perfectly,ajtai2010oblivious} and differential privacy~\cite{wagh2016root}, and item lookup with cuckoo hashing~\cite{pinkas2010oblivious} and bloom filters~\cite{williams2008building}.
If most ORAM constructions are based on a single client server model, multi-user designs were gradually introduced as \cite{backesanonymous} in 2016 which also provides user anonymity, some relying on right delegation~\cite{franz2011oblivious} or group access~\cite{goodrich2012privacy}.
As we stated before the eviction process is one of the principal problem of ORAM, the clients have to re-encrypt and process the whole database for extensive period of time during which record access is usually not possible, some designs permitting read while shuffling as \cite{boneh2011}.\\

\noindent\textbf{Shuffling and Sorting.}
Shuffle and sorting algorithms are a thoroughly researched subject central to ORAM for the randomization process. However most of them are not oblivious in that the memory accesses done by algorithm depends on the input.
Examples of oblivious sorting algorithms include sorting networks such as Batcher's~\cite{batcher1968sorting} and the ones based on AKS~\cite{ajtai19830} which were proved to be impractical because of the number of I/Os, Batchers using $\mathcal{O}\left ( n \log n \right)$ I/Os and AKS having a high constant factor, but also more recent and efficient ones~\cite{paterson1990improved}.
The randomized Shellsort ~\cite{goodrich2010randomized} is an elegant simple data-oblivious version of the Shellsort algorithm running in $\mathcal{O}\left ( n \log n \right)$ time that sort with high probability.
The Zig Zag sort~\cite{goodrich2014zig}, presented in 2014, is the deterministic data-oblivious variant of the Shellsort with running time of $\mathcal{O}\left ( n \log n\right)$.
Lastly, the bucket sort Algorithm was both studied in Melbourne shuffle~\cite{ohrimenko2014melbourne} where a user rely on temporary arrays and dummies and in \cite{goodrich2012anonymous} with the use of a parallel mixnet.\\

\noindent\textbf{Mix-nets.}
Mix-nets were first presented for anonymous e-mailing by David Chaum in 1981~\cite{chaum1981untraceable}. As they became popular many improvements were made over the years~\cite{moller2003mixmaster,danezis2003mixminion,danezis2004minx,danezis2009sphinx} and new applications such as anonymous web browsing with Tor~\cite{dingledine2004tor} appeared. Mix-net's main goal is to give users some anonymity by hiding the correspondence between the incoming users' packets and the mix-nets output. To do so, the users' packets go through several mixes which permute them and refresh their encryption. Either reencryption~\cite{wikstrom2006adaptively} and onion encryption can be used, proofs of shuffle~\cite{groth2007verifiable,groth2007non,bayer2012efficient} and Randomized Partial Checking~\cite{jakobsson2002making} can help verify the shuffle correctness.\\
This work is inspired by mix-net and its encryption and permutation functionalities. Our design however only accept messages from a single user at a time to reach only packet unlinkability.
%
\section{Preliminaries}\label{Prelim}
%
\subsection{Model}\label{Model}
We consider on one side, an ORAM remote server with memory capacity of $n\ b$-bit long blocks, a mix-net composed of $m$ mixes and on the other side, a client with memory of $s$-block capacity with $s<<n$. The remote server can additionally includes a small memory of capacity $\mathcal{O}(m)$ to store extra information such as the permutation seeds and encryption keys.\\\
%
We consider here the use of ORAM on the cloud. As such, the cloud primitives are available at the server side. 
\begin{itemize}
 \item get(index): Returns the record located at $index$.
 \item get\_range($index_i$, $index_j$): Returns the records comprised between $index_i$ and $index_j$.
 \item put(index, data\_block):  Writes the data block at $index$, returns an error if the data block is too large.
 \item put\_range($index_i$, $index_j$, data\_blocks): Writes the data blocks between $index_i$ and $index_j$, returns an error if the data block are too large.
\end{itemize}

%
\subsection{Threat model and Security definition}\label{Threat}

The ORAM design, defined in Def.~\ref{def:Oram}, assumes the existence of motivated adversaries trying to subvert the user's privacy and perhaps his data integrity.
The adversaries might have different goals such as identifying a user data access or matching encrypted data-blocks with known plaintext. 
\noindent We assume that all communication between the different parties (user, ORAM server and mixes) may be intercepted as in the \textit{global passive adversary} assumption however only message timing, volume and size from honest parties can be known thanks to packet encryption.
In addition, we assume the adversaries may have corrupted the ORAM server and a part of the mix-net to achieve his goal.
We will assume that the compromised machines present a \textit{honest but curious} behaviour in that every operation is correctly performed but passively recorded.

\begin{privdef}\label{def:Oram}
Let $\text{seq}_k=((\text{op}_1, \text{addr}_1, \text{data}_1), \text{ ...},(\text{op}_k, \text{addr}_k, \text{data}_k))$ denote a query sequence of length $k$, where $op$ denotes a read or write operation and $data$ the block to write else $
\perp$.
We denote by $ORAM(seq_k)$ the resulting randomized data access from the ORAM process with input $seq_k$.
The ORAM guarantees that $ORAM(seq_k)$ and $ORAM(seq'_{k'})$ are computationally indistinguishable if their lengths are equal ($k=k'$).
\end{privdef}


This work focuses on the ORAM eviction process where sequences of data-blocks are merged in an oblivious manner in order to hide the records indexes after access information has leaked. For instance, in the Square Root solution the problem refers to the eviction of the shelter in the database and the upper partitions in a lower one in the Partition cases. We  evaluate it through the following security game.
%
\iffalse
\begin{privdef}
An ORAM eviction process is considered oblivious if an adversary cannot distinguish after eviction whether a specific record has been accessed.\\
That is to say, for the eviction of $s$ elements in an array of $n$ elements, and with $\epsilon =\mathcal{O}\left ( \frac{1}{n} \right )$, we have, $$ \forall i \in \llbracket 1, n \rrbracket,\ |\Pr(index_i \text{ was not retrieved} ) - \Pr(index_i \text{ was retrieved} )| \leq \epsilon$$
\label{def:Oblivious}
\end{privdef}
\fi
%
\begin{secgme}
An adversary gives to the user two same size ORAM query sequences $\text{seq}_k$ and $\text{seq}_k'$. The user chooses randomly one of the two, executes it and start the eviction. At the end of the eviction the adversary picks which ORAM query sequence was chosen. The adversary wins if he chose the right sequence with probability higher than $\Pr = \frac{1}{2}+\epsilon$, with $\epsilon<<\frac{1}{2}$.
\label{def:Game}
\end{secgme} 
%
\iffalse
%% If comparision between initial thought and what is needed
\begin{privdef}{Eviction Old Security.}
An ORAM eviction process is considered secure if an adversary cannot distinguish after eviction the location of any specific record. 
\end{privdef}
\fi
%
\noindent\textbf{Costs.} We denote the communication costs by $C_{oram}$ for the number of \emph{bits} sent by the ORAM, $C_{client}$ by the client per mix, and by $C_{mix}$ sent per mix. 
We will call $C_{cmp}$ the computation cost derived from the eviction.
%
\subsection{Cryptographic Primitives}
\noindent\textbf{PRG \& Seeds.}
ORAM needs to periodically shuffle the records to hide the corresponding indices. To do so, pseudorandom generators (PRG) and seeds are used to save the matching between remote and real indices.\\
A distribution $\mathcal{D}$ over strings of length $l$ is said pseudorandom if $\mathcal{D}$ is indistinguishable from the uniform distribution over strings of length $l$~\cite{katz2014introduction}. That means it is infeasible for any polynomial-time adversary to tell whether the string was sampled accordingly to $D$ or was chosen uniformly at random. A pseudo-random generator (PRG) is a deterministic algorithm that receives as an input a short random seed and stretches it into a long pseudorandom .\\\

\noindent\textbf{Encryption.}
ORAM designs heavily rely on encryption mechanism to obfuscate the database records as the records must be re-encrypted during the eviction and access processes, which implies computation cost of the order of $\mathcal{O} \left ( n \right )$ and between $\mathcal{O} \left ( 1 \right )$ and $\mathcal{O} \left ( \log n \right )$ usually.\\\
Advanced Encryption Standard (AES) was conceived for high speed and low RAM requirements. It can present throughput over 700 MB/s per thread on recent CPUs such as the Intel Core i3 which makes it the ideal choice for ORAM.\\
AES in CBC mode (AES-CBC) is one of the most common mode of operation used today. It works sequentially, as the ciphertext of one message is needed for the encryption of the next one. 
AES in Counter mode (AES-CTR) encryption and decryption operations are commutable and commutative.
%
\section{Mix-ORAM}\label{Mix-ORAM}
After looking at a simple but impractical Mix-ORAM we will look closely at the eviction process and the use of shuffle algorithms, we will then apply the result to a traditional client-server ORAM and finally to the mix-ORAM.
%
\subsection{Architecture \& Encryption}\label{Arch}
%
\noindent\textbf{Permuting.} ORAM designs frequently uses PRGs during the eviction algorithm to shuffle obliviously the records and store the mapping between virtual and real indexes.
In the case of classic client-server configuration, the client just needs to retrieve the database, permute them locally according to a new seed and upload them back. Yet, with the introduction of the mix-net, we have a shift of paradigm: the permutations are now executed by the semi-trusted mix-net. Thereby, only private permutation seeds are provided to each mix so that the adversaries only have a partial view of the permutation process and cannot figure out the matching between remote and real indices.\\
Because the symmetric group is not commutative and the seeds space is not structured, finding combinations of permutations cancelling each other can only be done through heavy computation. That is why every eviction process will now be split in two phases, the unwrapping of the previous permutations and the wrapping to the next ones, of $r$ rounds each.\\
We will consider in this paper two different kinds of mix-nets. Cascade mix-nets, as shown in Fig.~\ref{fig:mix_cas}, consist of mixes positioned ones after the others in a fix order ($r=m$), with one entry and one exit. Parallel mix-nets, shown in Fig.~\ref{fig:mix_par}, comprise mixes are positioned in parallel, with every mix being an entry and exit. During one round, the packets received by a mix are processed and then distributed among all the mixes once again.\\

\begin{figure}[t]
\centering
\begin{minipage}[c]{0.475\textwidth}
\vspace{0pt}
\begin{adjustbox}{width=\textwidth}
\centering 
\begin{tikzpicture}[->, auto, semithick,  node distance = 5em]
\tikzstyle{every state}=[fill=white,draw=black,thick,text=black]

\node[draw=none, fill=none]    		(X)   {};
\node[draw, rectangle]   		(A)[right of=X]   {\small $Mix_{1}$};
\node[draw, rectangle]    		(B)[right of=A]   {\small $Mix_2$};
\node[draw, rectangle]    		(C)[right of=B]   {\small $Mix_3$};
\node[draw=none, fill=none]    		(Y)[right of=C]   {};

\path
(X.east) edge     	node{}    	(A.west)
(A.east) edge     	node{}    	(B.west)
(B.east) edge     	node{}    	(C.west)
(C.east) edge     	node{}    	(Y.west);

\end{tikzpicture}
\end{adjustbox}
\caption{A Cascade mix-net} \label{fig:mix_cas}
\end{minipage}
\hfill
\begin{minipage}[T]{0.475\textwidth}
\vspace{0pt}
\centering 
\begin{adjustbox}{width=\textwidth}
\begin{tikzpicture}[->, auto, semithick,  node distance = 5em]
\tikzstyle{every state}=[fill=white,draw=black,thick,text=black]

\node[draw=none, fill=none]    		(X)   {};
\node[draw, rectangle]    		(B)[right of=X]   {\small $Mix_2$};
\node[draw, rectangle]   		(A)[above of=B]   {\small $Mix_{1}$};
\node[draw, rectangle]    		(C)[below of=B]   {\small $Mix_3$};
\node[draw, rectangle]   		(A')[right of=A]   {\small $Mix_{1}$};
\node[draw, rectangle]    		(B')[right of=B]   {\small $Mix_2$};
\node[draw, rectangle]    		(C')[right of=C]   {\small $Mix_3$};
\node[draw, rectangle]   		(A'')[right of=A']   {\small $Mix_{1}$};
\node[draw, rectangle]    		(B'')[right of=B']   {\small $Mix_2$};
\node[draw, rectangle]    		(C'')[right of=C']   {\small $Mix_3$};
\node[draw=none, fill=none]    		(Y)[right of=B'']   {};

\path
(X.east) edge     	node{}    	(A.west)
(X.east) edge     	node{}    	(B.west)
(X.east) edge     	node{}    	(C.west)
(A.east) edge     	node{}    	(A'.west)
(A.east) edge     	node{}    	(B'.west)
(A.east) edge     	node{}    	(C'.west)
(B.east) edge     	node{}    	(A'.west)
(B.east) edge     	node{}    	(B'.west)
(B.east) edge     	node{}    	(C'.west)
(C.east) edge     	node{}    	(A'.west)
(C.east) edge     	node{}    	(B'.west)
(C.east) edge     	node{}    	(C'.west)
(A'.east) edge     	node{}    	(A''.west)
(A'.east) edge     	node{}    	(B''.west)
(A'.east) edge     	node{}    	(C''.west)
(B'.east) edge     	node{}    	(A''.west)
(B'.east) edge     	node{}    	(B''.west)
(B'.east) edge     	node{}    	(C''.west)
(C'.east) edge     	node{}    	(A''.west)
(C'.east) edge     	node{}    	(B''.west)
(C'.east) edge     	node{}    	(C''.west)
(A''.east) edge     	node{}    	(Y.west)
(B''.east) edge     	node{}    	(Y.west)
(C''.east) edge     	node{}    	(Y.west);

\end{tikzpicture}
\end{adjustbox}
\caption{A Parallel Mixnet} \label{fig:mix_par}
\end{minipage}
\end{figure} 
%

\noindent\textbf{Encrypting.} We will consider in this paper two ways to re-encrypt the database, independently of the mix-net architecture. The first method increases the number of decryption done by the user, the second keeps this number constant at the cost of higher computation.\\

In the first method, we simply let the mix keep encrypting the records with AES-CBC. Before uploading the records to the cloud, the user append to them a token to generate an IV. The records are then encrypted by the mixes with AES-CBC and these unique IVs. Before transferring the records to the next mix(es), the IV tokens are also obfuscated thanks to AES-ECB and the mix private key.
The user when retrieving a record will have to decipher all the AES-CBC encryption layers in a trial error fashion: the client will remove $r$ encryption, check if the record is only encrypted with the user encryption if not restart the process.\\
There is in total $k_i \cdot r$, $k\in \mathbb{N}$, encryption layers per record $rec_i$. If the record access frequency distribution was close to uniform, the $k_i$ would follow a Binomial distribution $\mathcal{B}\left ( e, \frac{s}{n}\right )$ with $e$ the number of evictions done before and would be comprised in a relatively small interval. However, in reality, the frequency distribution is not uniform and the $k_i$ are more sparsely distributed. In any case, since the duration of the record decryption can be significantly different, a timing attack can occur. This is why, we advise to change the access method as the following: when a user access a record, he fetches $d$ other records, re-encrypt all of them and uploads them back at the same indices. The number of records fetched before eviction is thus increased to $s\cdot d$, most of which were done randomly. The average and maximum time to decipher is thus reduced, with a large enough $d$ the total deciphering duration is closed to constant so the timing attack mitigated.\\

\noindent\textit{Considering fake access.} When a user wants to access a record which already is in the stash, a random database access is performed to hide potential frequency attacks. These fake accesses can be considered as free permutations as no fetched records need to remain in the stash, thus we can arbitrarily set $k_{in}=k_{out}$.
%
\begin{secthm}
In the case of a uniform distribution access we have an average number 0 of fake access for $s<<n$.
\end{secthm}
%
However it is well known that the frequency access of records is not uniform, in that case we can count a strictly positive number of fake accesses.
\begin{secthm}
Let $A$ be the access distribution. Let's call $v_0$ and $v_1$ the volume above the line $y=0$ and under it respectively.
The average number of fake access is $ \frac{v0}{v1}$.
\begin{proof}
 The volume under such line represents the number of real accesses a user does while the volume above it represents accesses in the stash which leads to fake accesses.
 When the number of accesses is great, the access frequency approaches the average number of accesses.
\end{proof}
\end{secthm}

\begin{figure}[t]
\centering
\begin{adjustbox}{width=\textwidth}
\centering 
\begin{tikzpicture}[->, auto, semithick,  node distance = 6em]
\tikzstyle{every state}=[fill=white,draw=black,thick,text=black]

\node[draw=none, fill=none]    	(X)				  {};
\node[draw, rectangle, align=center]   		(A)[right of=X]   {\small $\mathbf{U}$\\$D_1$};
\node[draw, rectangle, align=center]    		(B)[right of=A]   {\small $\mathbf{E}$\\$E_2'$};
\node[draw, rectangle, align=center]    		(C)[right of=B]   {\small $\mathbf{D}$\\ $D_2,\ B$};
\node[draw, rectangle, align=center]    		(D)[right of=C]   {\small $\mathbf{W}$\\$E_1'$};
\node[draw=none,fill=none]    	(Y)[right of=D]	  {};

\path
(X.east) edge     	node{\small $ E_{2}E_{1}$}    	(A.west)
(A.east) edge     	node{\small $ E_{2}$}    	(B.west)
(B.east) edge     	node{\small $ E_{2}'E_{2}$}    	(C.west)
(C.east) edge     	node{\small $ E_{2}'$}    	(D.west)
(D.east) edge     	node{\small $ E_{2}'E_{1}'$}    	(Y.west);
\end{tikzpicture}
\end{adjustbox}
\caption{AES-CTR} \label{fig:AES}
\end{figure}
\squeezeup
The second method consists in decrypting the old encryption layers and encrypting again, we do so with AES-CTR. Because the records are permuted at every round, the ordering keep changing, we cannot use AES-CTR commutativity and have to decrypt in the exact reverse order of the previous encryption. After the unwrapping and decryption is done, the records are only encrypted with the user encryption and are in an invariant ordering. The adversary looking at successive evictions can spot at this moment which records were accessed by simply observing which user encryption has changed. To prevent such attack, we add two additional phases between the unwrapping ($U$) and wrapping ($W$) where the every mix encrypts ($E$) and decrypts ($D$) the records with unchanged order (to use AES-CTR commutativity) as depicted in Fig~\ref{fig:AES}. 
\iffalse
\squeezeup
\begin{figure}[H]
\centering
\begin{adjustbox}{width=\textwidth}
\centering
\begin{tikzpicture}[->, auto, semithick,  node distance = 5em]
\tikzstyle{every state}=[fill=white,draw=black,thick,text=black]

\node[draw=none, fill = none]    	(Z)				  {};
\node[draw=none, fill = none]    	(Z')[right of= Z]				  {};

\node[draw, rectangle]    	(I)[right of= Z']				  {\small {$Mix_i$}};

\node[draw=none, fill = none]    	(Y)[right of =I]				  {};
\node[draw=none, fill = none]    	(Y')[right of =Y]				  {};

\node[draw, rectangle]    	(A)[right of=Y']			  {\small {$Mix_{i+1}$}};
\node[draw=none, fill = none]    	(X)[below of=A]				  {\small {...}};

\node[draw, rectangle]    	(B)[below of=X]				  {\small {$Mix_{i-1}$}};

\path
([yshift=1ex]Z.east) edge[align=left]     	node{\small $(E_{EG}(tag_j)),\  rec_j$}    	([yshift=1ex]I.west)
([yshift=-1ex]I.west) edge     	node[align=left] {\small $ E_{EG}(tag_j),$\\$ E_i(rec_j^{(m)})\oplus_{k=1}^m blind_{j,k}$}    	([yshift=-1ex]Z.east)

([yshift=1ex]I.east) edge     	node {\small $ tag_j, E_i(rec_j)=rec_j'$}    	([yshift=1ex]A.west)
(A.south) edge     	node[align=left] {\small $ tag_j,\ rec_j^{(2)}\oplus blind_{j,i+1}$}    	(X.north)
(X.south) edge     	node[align=left] {\small $ tag_j,\ rec_j^{(m-1)} \oplus_{k \neq i-1}^{k \neq i} blind_{j,k}$}    	(B.north)
(B.west) edge[bend right]     	node[align=right] {\small \\ $ tag_j,$\\$rec_j^{(m)}\oplus_{k \neq i} blind_{j,k}$}    	([yshift=-1ex]I.east);

\end{tikzpicture}
\end{adjustbox}
\caption{Blind} \label{fig:TAG}
\end{figure}
\squeezeup
\fi
%

\subsection{A simple Mix-ORAM}\label{SMO}
%
We consider here the basic cases where the whole database is sent through a cascade mix-net during the eviction process.\\

\noindent\textbf{Using AES-CBC.} In this scheme, each mix re-encrypts the whole database, and remove or add a permutation layer depending on the phase, before sending it to the next mix as depicted in Fig~\ref{fig:ASMO_CBC}.\\
%
\begin{figure}
\centering
\begin{adjustbox}{width=\textwidth}
\begin{tikzpicture}[->, auto, semithick,  node distance = 7em]
\tikzstyle{every state}=[fill=white,draw=black,thick,text=black]
\node[draw, cylinder, shape border rotate=90,minimum height=10ex,minimum width=3ex]    	(0)				  {};	
\node[draw, rectangle]   		(A)[right of=0]   {\small $Mix_{1}$};
\node[draw=none, fill=none]    		(X)[right of=A]   {\small $...$};
\node[draw, rectangle]    		(B)[right of=X]   {\small $Mix_m$};

\path
([yshift=1ex]0.east) edge     	node{\small $DB_{k_{i=1..2m}}^{S_j=1..m}$}    	([yshift=1ex]A.west)
([yshift=-1ex]A.west) edge     	node{\small $DB_{k_{i=1..4m}}^{S'_{j=1..m}}$}    	([yshift=-1ex]0.east)

([yshift=1ex]A.east) edge     	node{\small $k_{2m+1},S_1^{-1}$}    	([yshift=1ex]X.west)
([yshift=-1ex]X.west) edge     	node{\small $k_{4m}',S_2'$}    	([yshift=-1ex]A.east)

([yshift=1ex]X.east) edge     	node{\small $k_{3m-1},S_{m-1}^{-1}$}    	([yshift=1ex]B.west)
([yshift=-1ex]B.west) edge     	node{\small $k_{3m+1}',S_{m}'$}    	([yshift=-1ex]X.east)

(B)    edge[loop right, dashed]    node{\small $k_{3m},S_{2m}^{-1}$} (B);

\end{tikzpicture}
\end{adjustbox}
\caption{A simple Mix-ORAM: AES-CBC} \label{fig:ASMO_CBC}
\end{figure} 

\noindent\textbf{Message Format.}
To reduce to as much as possible the message size, we choose to derive the AES keys and the permutation seeds from shared secrets calculated in a Diffie-Hellman assumption as in Sphinx~\cite{danezis2009sphinx} with the HKDF function~\cite{krawczyk2010cryptographic}.
The client provides to each mix the old shared secret $\alpha_{old}$ to unwrap the permutation, the new shared secret $\alpha_{new}$ to encrypt and sort to the new permutation alongside with the signed list of mixes $(ports,\ ips)_{signed}$ and the database access information $id$ and token $token$
$$E_{pub,\ mix_i}\left ( id,\ token,\ (ports,\ ips)_{signed},\ \alpha_{i,\ old},\ \alpha_{i,\ new} \right) $$

\noindent\textbf{Costs.}
We have $c_{cmp} = 2\cdot m \cdot n \cdot c_{CBC}$, $c_{client}= x$, $c_{mix}=2\cdot m \cdot n$. The total communication cost is $c_{com}=2\cdot m\cdot n + m\cdot c_{client}$.\\

\noindent\textbf{Using AES-CTR.} Each of the mixes decrypt and unwrap the records in the first phase then wrap and encrypt in the second, each phase consisting of $2 \cdot m$ rounds and at the middle of each phase, a blinding patch is done as depicted in Fig~\ref{fig:ASMO_CTR}.\\

\begin{figure}
\centering
\begin{tikzpicture}[->, auto, semithick, node distance = 8em, every loop/.style={<-}]
\tikzstyle{every state}=[fill=white,draw=black,thick,text=black]


\node[draw, cylinder, shape border rotate=90,minimum height=3cm,minimum width=1cm, anchor=west]    	(0)				  {};	
\node[draw, rectangle]   		(A)[right =of 0.north, anchor = north]   {\small $Mix_{1}$};
\node[draw, rectangle] (A')[right of=0]{\small $Mix_{1}$};
\node[draw, rectangle]   		(A'')[right=of 0.south, anchor = south]   {\small $Mix_{1}$};

\node[draw=none, fill=none]    		(X)[right of=A]   {\small $...$};
\node[draw=none, fill=none]    		(X')[right of=A']   {\small $...$};
\node[draw=none, fill=none]    		(X'')[right of=A'']   {\small $...$};

\node[draw, rectangle]    		(B)[right of= X]   {\small $Mix_m$};
\node[draw, rectangle]    		(B')[right of=X']   {\small $Mix_{m}$};
\node[draw, rectangle]    		(B'')[right of= X'']   {\small $Mix_m$};

\path 
([yshift=0.85cm]0.north east) edge     	node{\small $DB_{k_{i=1..2m}}^{S_{j=1..m}}$}    	(A.west)

(A.east) edge node{$k_{1},\ S_{1}^{-1}$}    	(X.west)

(X.east) edge node{$k_{m-1},\ S_{m-1}^{-1}$}    	(B.west)

(B.east) edge[bend left] node{$k_{m},\ S_{m}^{-1}$} ([yshift=1ex]B'.east)

([yshift=1ex]B'.west) edge[align=center] node[above]{$k_{2m}'$} node[below]{$k_{2m-1}$}    	([yshift=1ex]X'.east)

([yshift=1ex]X'.west) edge[align=center] node[above]{$k_{m+2}'$} node[below]{$k_{m+1}$}    	([yshift=1ex]A'.east)

([yshift=-1ex]A'.east) edge[align=center] node[above]{$k_{2m}$} node[below]{$k_{m+1}'$} (B''.west)

([yshift=-1ex]B''.west) edge    node{$k_{m}',\ S_{m}'$}  ([yshift=-1ex]X''.east)

([yshift=-1ex]X''.west) edge    node{$k_{2}',\ S_{2}'$}  ([yshift=-1ex]A''.east)

([yshift=-1ex]A''.west) edge node{\small $DB_{k_{i=1..2m}'}^{S_{j=1..m}'}$} ([yshift=-0.8cm]0.south east);


\end{tikzpicture}
\caption{A simple Mix-ORAM: AES-CTR} \label{fig:ASMO_CTR}
\end{figure} 
%

\noindent\textbf{Message Format.}
We derive the keys and seeds as previously however we produce twice more shared keys than usual for the wrapping and unwrapping phases. \iffalse\\
Let $\kappa$ be the security parameter. We call $\mathcal{G}$ a prime order cyclic group satisfying the Decisional Diffie-Hellman Assumption. $\mathcal{G}^*$ is the set of non-identity elements of $\mathcal{G}$. The element $g$ is a generator of the group, and $q$ is the prime order of $\mathcal{G}$ with $q \approx 2^{2\kappa}$.\\
We suppose each mix owns a pair of keys ($\ priv_i \in \mathbb{Z}_{q}^*$, $pub_i=g^{priv_i}\in \mathcal{G}^*$). We assume the existence of a PKI that publishes a list of all ($mix_i$,\ $pub_i$) pair.
The client randomly chooses $x\in_\mathcal{R} \mathbb{Z}_q^*$ and sends to the mix $mix_i$ the element $\alpha_i=g^{x\cdot b_i}$ with $b_i$ a binding factors, the shared secret is then $s_i=pub_i^{x\cdot b_i}$.
\fi
The client only need to send to the mixnet session keys to access the database $(id,\ token)$, the client secrets used to compute the shared secret $( \alpha_{i,old},\ \alpha_{i,new} )$, the threshold secret $sec$ and the signed next mix addresses $(ports,ips)_{signed}= \left (\ ...,\ E_{pub,\ mix_{i}}\left ((port_{mix_{i+1}}, ip_{mix_{i+1}})_{signed}\right),\ ...\right)$.
The message format is then : $$E_{pub,\ mix_i}\left(id,\ token,\ \alpha_{i,old},\ \alpha_{i,new},\ sec,\ (ports,ips)_{signed} \right)$$ 


\noindent\textbf{Costs.} For 128-bit security, group elements can be expressed in just 32 bytes. We have $c_{cmp} = 3 \cdot m \cdot n \cdot c_{CTR} $, $c_{client}=  x$, $c_{mix}=3n$. The total communication cost is $c_{com}=3 \ cdot m \cdot n + c_{client}$.\\


These schemes are not efficient as instead of re-encrypting each record twice as in the Melbourne Shuffle, at least $2\cdot m$ encryption per element are necessary to achieve perfect security. The whole database also goes through every node twice which incur severe delays. To increase the mix-net efficiency, we study in the following sectin parallelization to distributing the workload among mixes.
%
\subsection{Parallelizing the Eviction process.}\label{Parallel}
In this section, we use random transposition shuffles (RTS) to model the parallelization  and calculate the number of rounds needed to reach perfect security.
We first present the mixing time of $k$-RTS before introducing ORAM assumptions to reduce the expected time to achieve randomness.
%
\subsubsection{$k$-Random Transposition Shuffle.}\label{kRTS}
% Def of RTS. RTS can be broken down in independant rounds which is nice for amortization. RTS can be made oblivious by making the permutations locally. The mixing time for RTS is high, we look at oblivious k-RTS.
Random Transposition Shuffles (RTS) are widely used examples in the study of card shuffling. It consists in a player picking randomly a couple of cards from a same deck, permuting them according to a coin toss and putting them back at the same location.
These steps, usually called a round, are then repeated until the deck of cards has been properly shuffled, i.e. until every card arranging is possible.\\
We can already see why RTS are natural candidates for amortized ORAMs : if they can be broke down in independent rounds which can be spread over several entities and time, so can a randomization process based on them. Furthermore, having the client (player) permuting the data blocks (cards) locally is enough to make RTS oblivious to the eyes of an adversary.
Diaconis in 1986~\cite{aldous1986shuffling} has proved that the RTS mixing time of a deck of $n$ cards is of the order of $n\log(n)$. We thus first look at oblivious $k$-RTS, an RTS where the client picks and transposes locally $k$ distinct cards to make the scheme more efficient. We stress the difference between doing successively $k/2$ transpositions and what we call $k$-RTS: in the first case, an element can be transposed several times in a row which leads to a different probability distribution. The result we present affirms that  $k$-RTS converges to the uniform distribution more rapidly than repeating normal RTS.  

\begin{secthm}
\textbf{Mixing time of $k$-RTS.} A $k$-random permutation shuffle of a $n$ card game reaches the uniform distribution in $\tau$ rounds, such that
$$E(\tau) < \frac{2}{k}\cdot\frac{n^2}{n+1}\cdot \left ( \log(n) + \mathcal{O}(1) \right ) $$
\begin{proof}
The proof can be found in Appendix~\ref{proof:kRTS}.
\end{proof}
\end{secthm}

PRG seeds actually do not ensure strict transpositions between elements but permutations, that is to say the number of transpositions done while using PRG seeds can be greater than the ones we considered. Hence, the uniform distribution is reached even more quickly. We thus consider that an oblivious $k$-RTS implies computation and communication cost of the order of $\mathcal{O} \left(\frac{n}{k}\cdot \log(n)\right)$.\\

When different parties, the $m$ mixes in our case, perform in parallel the $k$-RTS, we can improve by another factor $m$ the eviction computation time. However, as some mixes can have been compromised by the adversary we ask each mix to perform $2 m\log n$ rounds.
%
\subsubsection{Oblivious Merge}\label{OM}
Before the eviction algorithm is run, the database can be divided in two sets of records depending on whether or not they were retrieved by the user. As such, the database can be represented as a simple binary array of $n$ bits out of which $s$ are 1s, the accessed ones, and $n-s$ are 0s, the others.
We argue that in this representation, elements of the same sets are indistinguishable to the adversary thanks to prior encryptions and permutations and thus, less rounds are necessary to correctly shuffle the database.\\

Indeed, this assumption significantly reduces the number of possible orderings in the adversarial view. We can prove, thanks to the Bars and Stripes theorem, that there now are ${n \choose s}$ orderings instead of $n!$.

We now consider the RTS process in that scenario and suppose the records (the bits) are re-encrypted before being permuting such that the merge of the two sets is oblivious to the adversary.

\begin{secthm}
An oblivious merge (OM) of 2 indistinguishable sets of respective size $n$ and $s$ elements requires $\tau$ rounds of 2-RTS such that any arranging is possible, with
$$\tau(\epsilon) \leq \frac{n}{2}  \cdot \left [ \left( \log \left (\frac{n}{s}-0.5\right) +\mathcal{O}\left(1\right) \right ) - \frac{2}{s} \log \left( 4 \cdot \epsilon\right) \right ] $$%&\\
\begin{proof}
The proof can be found in Appendix~\ref{proof:OM}.
\end{proof}
\end{secthm}

\begin{seccjt}\label{sec:kOM}
A $k$-oblivious Merge ($k$-OM) of 2 indistinguishable sets of respective size $n$ and $s$ requires $\tau$ rounds doing of $k$-RTS such that any arranging is possible, with
$$ \tau(\epsilon) \leq \frac{n}{2\cdot k}  \cdot \left [ \left( \log \left (\frac{n}{s}-0.5\right) +\mathcal{O}\left(1\right) \right ) - \frac{2}{s} \log \left( 4 \cdot \epsilon\right) \right ] $$
\begin{proof}
We could see that permuting $k$ elements in RTS decreased the mixing time by at least a factor $k$, and does so independently of the items to shuffle. Thereby the decrease should still be relevant here.
\end{proof}
\end{seccjt}
%
\subsection{Parallel Mix-ORAM}\label{parallelMixORAM}
%
We now consider the mix-net as a collection of isolated mixes. The unwrapping and wrapping phases consist of $r= \frac{m}{2} \cdot \log \left (\frac{n}{s} \right ) $ rounds as depicted in Fig~\ref{fig:Par}.\\

\begin{figure}
\centering
\begin{minipage}[t]{0.45\textwidth}
\begin{tikzpicture}[->,
auto,
semithick, 
scale=0.5,
block/.style={draw, fill=white, rectangle, font=\small}]

\node[block, align=center]							(B)		{$\textbf{Mix}_k$ \\ $ S_{k,r}$};
\node[draw=none, fill=none]    		(X)[above of=B, yshift=-1em]		[rotate=-90]{...};
\node[draw=none, fill=none]    		(Y)[below of=B, yshift=1em]		[rotate=-90]{...};
\node[block, anchor= north, align=center]			(A)[above of=B, yshift=1em]		{$\textbf{Mix}_1$ \\ $ S_{1,r}$};
\node[block, anchor = south, align=center]			(C)[below of=B, yshift=-1em]		{$\textbf{Mix}_m$ \\ $ S_{m,r}$};

\node[block, align=center]							(B')[left of=B, xshift=-5em]		{$\textbf{Mix}_k$ \\ $ S_{k,r-1}$};
\node[draw=none, fill=none]    		(X')[above of=B', yshift=-1em]		[rotate=-90]{...};
\node[draw=none, fill=none]    		(Y')[below of=B', yshift=1em]		[rotate=-90]{...};
\node[block, anchor= north, align=center]			(A')[above of=B', yshift=1em]		{$\textbf{Mix}_1$ \\ $ S_{1,r-1}$};
\node[block, anchor = south, align=center]			(C')[below of=B', yshift=-1em]		{$\textbf{Mix}_m$ \\ $ S_{m,r-1}$};


\node[block, anchor = east, minimum height=12em]		(1)[right of=B, xshift = 3em]		{$\text{DB}_{i}$};


\path[->, midway]
 (A')		edge node[above,yshift=4ex]		{$S_{pub,r}$} 	(A.west)
 (A')		edge node		{} 					(B.west)
 (B')		edge node		{} 					(C.west)
 (B') 		edge node		{} 					(A.west)
 (C') 		edge node		{} 					(A.west)
 (C') 		edge node		{} 					(C.west)

 (A.east) edge node[sloped, above]	{} 	([yshift=-2ex]1.north west)
 (B.east) edge node[sloped, above]	{} 	(1)
 (C.east) edge node[sloped, above]	{} 	([yshift=2ex]1.south west);
 
\end{tikzpicture}
\caption*{Last rounds of wrapping} \label{fig:WAS}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\textwidth}
\begin{tikzpicture}[->,
auto,
thin, 
scale=0.5,
block/.style={draw, fill=white, rectangle, font=\small}]


\node[block, anchor = west, minimum height=12em] 		(0)		{$\text{DB}_i$};

\node[block, align=center]							(B)[right of=0, xshift=3em]		{$\textbf{Mix}_k$ \\ $ S_{k,r}^{-1}$};
\node[draw=none, fill=none]    		(X)[above of=B, yshift=-1em]		[rotate=-90]{...};
\node[draw=none, fill=none]    		(Y)[below of=B, yshift=1em]		[rotate=-90]{...};
\node[block, anchor= north, align=center]			(A)[above of=B, yshift=1em]		{$\textbf{Mix}_1$ \\ $ S_{1,r}^{-1}$};
\node[block, anchor = south, align=center]			(C)[below of=B, yshift=-1em]		{$\textbf{Mix}_m$ \\ $ S_{m,r}^{-1}$};

\node[block, align=center]							(B')[right of=B, xshift=5em]		{$\textbf{Mix}_k$ \\ $ S_{k,r-1}^{-1}$};
\node[draw=none, fill=none]    		(X')[above of=B', yshift=-1em]	[rotate=-90]{...};
\node[draw=none, fill=none]    		(Y')[below of=B', yshift=1em]	[rotate=-90]{...};
\node[block, anchor= north, align=center]			(A')[above of=B', yshift=1em]	{$\textbf{Mix}_1$ \\ $ S_{1,r-1}^{-1}$};
\node[block, anchor = south, align=center]			(C')[below of=B', yshift=-1em]	{$\textbf{Mix}_m$ \\ $ S_{m,r-1}^{-1}$};


\path[->, midway]
 ([yshift=-2ex]0.north east) edge node[sloped, above]{} (A.west)
 (0) edge node[sloped, above]{} (B.west)
 ([yshift=2ex]0.south east) edge node[sloped, above]{} (C.west)

 (A.east) edge node[above,yshift=4ex]	{$S_{pub,r}^{-1}$} 	(A')
 (A.east) edge node						{} 					(B')
 (A.east) edge node						{} 					(C')
 (B.east) edge node						{} 					(A')
 (C.east) edge node						{} 					(B')
 (C.east) edge node						{} 					(C');
 
\end{tikzpicture}
\caption*{First rounds of unwrapping} \label{fig:UAS}
\end{minipage}
\caption{Wrapping and corresponding unwrapping.}\label{fig:Par}
\end{figure} 

\noindent\textbf{Using AES-CBC.} In this case, the mixes keep encrypting the records with the appended IVs during $r$ rounds of wrapping and unwrapping.\\

\noindent\textbf{Message Format.}
The client only need to send to each mix the signed message containing session keys to access the database $(id,\ token)$, information to compute which records it has been attributed $(index,\ range)$, the client's secret used to compute the shared secret $(\alpha_i,\ \alpha_i',\ \alpha_{pub},\ \alpha_{pub}')$, and the signed ordered $(ports,\ ips)$ of the mixes participating in the eviction.
The message format is then : $$E_{pub,\ mix_i}\left (id,\ token,\ index,\ range,\ \alpha_i,\ \alpha_i',\ \alpha_{pub},\ \alpha_{pub}',\ (port	s,\ ips)_{signed}\right )$$

\noindent\textbf{Costs.} For 128-bit security, group elements can be expressed in just 32 bytes, we have thus a maximum message size of $|addr|+XXX + 3 \cdot 8 \cdot 32 + XXX$. We have $c_{cmp} = 2\cdot r \cdot n \cdot c_{CBC}$, $c_{client}= x$, $c_{mix}= 2\cdot r \cdot n$ and $c_{com} = 2 \cdot r \cdot n+ c_{client}$.\\

\noindent\textbf{Using AES-CTR.}
When performing an eviction, the client assigns to each mix  $k=\frac{n}{m}$ distinct indexes together with a list of shared secrets from which will be derive public and private permutation seeds and encryption keys.\\
At first, the mixes fetch their allocated records from the database. They then unwrap the previous permutation: the last wrapping permutations are undone in reverse order thanks to the old private seeds and the records are decrypted with the old encryption keys before being distributed to all mixes according to the inverse permutation of the old public seeds. Then starts the wrapping as shown in the Algorithm.~\ref{alg:WAS}, where the records are permuted according to the new seeds, encrypted with the new encryption keys and distributed to the mixes according to the new public seeds. At the middle of the wrapping and unwrapping phases, we add a blinding phase where the mix generate and append, or remove, tags to each block. The tags are encrypted, decrypted and refreshed as said in Section~\ref{Arch}.\\
\iffalse
To find the ORAM index of a precise record, the client performs the index lookup function written in Algorithm.~\ref{alg:IAS}.
\fi
\\

\iffalse
\begin{figure}
\begin{minipage}[t]{0.475\textwidth}
\vspace{0pt}
\centering 
\begin{algorithm}[H]
\SetKwComment{Comment}{//}{}
\DontPrintSemicolon
\KwIn{Public seed $S_{pub,old,j}$;\\ \qquad Private seed $S_{prv,old,i,j}$; \\ \qquad Encryption key $Key_{new,i,j}$; \\ \qquad Number of records $k$; \\ \qquad First index $idx$;\\ \qquad Data $data$;}
$Rec \gets []$;\\
\If {$j=0 \ and \ i=1 $}
{
	$Rec \gets get\_range(idx+ik,idx+(i+1)k)$;\\
	$return \  Rec$;\\
}
$index \gets {\Pi}_{S_{pub,old,j}} \llbracket 1, m*k\rrbracket $;\\
$DB \gets []$;\\
\ForAll {$u \in \llbracket 1, m \rrbracket$}
{
	$DB.extend([[]])$;\\
	\ForAll {$v \in \llbracket 1, k \rrbracket$}
	{
		$r \gets index[u*k+v]$;\\
		\If {$ r\in \llbracket i*k,(i+1)*k-1 \rrbracket$}
		{
			$DB[u].extend( r)$;\\
		}
	}
}
$sorted \gets []$;\\
$records\gets []$;\\
\ForAll {$l \in \llbracket 1,m \rrbracket$}
{
	$sorted.extend(DB[l])$;\\
	$records.extend(data[l])$;\\
}
$zipped \gets zip(sorted, records)$;\\
$zipped.sort()$;\\
$Rec \gets [zipped[x][1] \text{ for x} \in \llbracket 1, len(zipped) \rrbracket]$;\\
$return \ Rec$;
\caption{Sort in for mix $i$ during round $j$}
\label{alg:SortIN}
\end{algorithm}
\end{minipage}
\hfill
\begin{minipage}[t]{0.475\textwidth}
\vspace{0pt}
\centering
\begin{algorithm}[H]
\SetKwComment{Comment}{//}{}
\DontPrintSemicolon
\KwIn{Public seed $S_{pub,new,j}$;\\ \qquad Private seed $S_{prv,new,i,j}$; \\ \qquad Encryption key $Key_{old,i,j}$; \\ \qquad Number of records $k$; \\ \qquad First index $idx$;}
\If {$j=r\ and\ i=m$}
{
	$put\_range(idx+k*i, idx+k*(i+1), data)$;\\
	$return$;\\
}
$index \gets {\Pi}_{S_{pub,new,j}} \llbracket 1, m*k \rrbracket$;\\
$index \gets index[\llbracket i*k: (i+1)*k-1\rrbracket]$;\\
$tosend \gets []$;\\
\ForAll {$l \in \llbracket 1,m \rrbracket$}
{
	$tosend.extend([[]])$;\\
}
\ForAll {$l \in \llbracket 1,k \rrbracket$}
{
	$tosend[index[l]/k].extend(data[l]))$;\\
}
\ForAll {$l \in \llbracket 1,m \rrbracket$}
{
	$send(DB_l, tosend[l])$;\\
}
\caption{Sort out for mix $i$ during round $j$}
\label{alg:SortOUT}
\end{algorithm}
\end{minipage}
\caption{Amortizable sort, sort in and sort out algorithms.}
\end{figure}
\begin{figure}
\begin{minipage}[t]{0.475\textwidth}
\vspace{0pt}
\centering 
\begin{algorithm}[H]
\SetKwComment{Comment}{//}{}
\DontPrintSemicolon
\KwIn{Public seed $S_{pub,old,j}$;\\ \qquad Private seed $S_{prv,old,i,j}$; \\ \qquad Encryption key $Key_{new,i,j}$; \\ \qquad Number of records $k$; \\ \qquad First index $idx$;\\ \qquad Data $data$;}
$Rcds \gets sort\_in(S_{pub,old,j}, data)$;\\
$Rcds \gets {\Pi}_{S_{prv,old,i,j}}^{-1} (data)$;\\
\ForAll{$r\in Rcds$}
{
	$r \gets encrypt_{Key_{new,i,j}}\left( r \right )$;\\
}
$sort\_in(S_{pub,old,j}, data)$;\\
$\textbf{del } S_{pub,old,j},\ S_{priv,old,i,j}$;\\
\caption{Unwrapping process for the mix $i$ during round $j$}
\label{alg:UAS}
\end{algorithm}
\end{minipage}
\hfill
\begin{minipage}[t]{0.475\textwidth}
\vspace{0pt}
\centering
\begin{algorithm}[H]
\SetKwComment{Comment}{//}{}
\DontPrintSemicolon
\KwIn{Public seed $S_{pub,new,j}$;\\ \qquad Private seed $S_{prv,new,i,j}$; \\ \qquad Encryption key $Key_{old,i,j}$; \\ \qquad Number of records $k$; \\ \qquad First index $idx$;\\ \qquad Data $data$;}
$Rcds \gets sort\_in(S_{pub,new,j}, data)$;\\
$Rcds \gets {\Pi}_{S_{prv,new,i,j}} (data)$;\\
\ForAll{$r\in Rcds$}
{
	$r \gets encrypt_{Key_{old,i,j}}\left( r \right )$;\\
}
$sort\_in(S_{pub,new,j}, data)$;\\
$\textbf{del } Key_{old,i,j}$;\\
\caption{Wrapping process for the mix $i$ during round $j$}
\label{alg:WAS}
\end{algorithm}
\end{minipage}
\caption{Amortizable sort, wrapping and unwrapping algorithms.\todo{add blinding}}
\end{figure}



\begin{figure}
\centering
\begin{minipage}{0.5\textwidth}
\begin{algorithm}[H]
\SetKwComment{Comment}{//}{}
\DontPrintSemicolon
\KwIn{Seeds $S_{pub},\ S_{prv}$; \\ \qquad Total number of records $n$; \\ \qquad Number of mixes $m$;\\ \qquad Number of rounds $r$;\\ \qquad Index to retrieve $index$;}
$k \gets \frac{n}{m}$;\\
$i \gets 0$;\\
\While{$i < r$}
{
	$mix \gets \frac{index}{k} $;\\
	$idx \gets index\ \%\ k$;\\
	$idx \gets {\Pi}_{S_{prv, mix, i}}(idx) $;\\
	$index \gets {\Pi}_{S_{pub, i}}(k*mix+idx)$;\\
	$i\gets i+1$;
}
\KwOut{$index$}
\caption{Index Lookup}
\label{alg:IAS}
\end{algorithm}
\end{minipage}
\end{figure}
\fi

\noindent\textbf{Message Format.}
The client send the same data as in the AES-CBC case together with the El Gamal secret share $sec$.
The message format is then : $$E_{pub,\ mix_i}\left (id,\ token,\ index,\ range,\ \alpha_i,\ \alpha_i',\ \alpha_{pub},\ \alpha_{pub}',\ sec,\ (ports,\ ips)_{signed}\right )$$

\noindent\textbf{Costs.} For 128-bit security, group elements can be expressed in just 32 bytes, we have thus a maximum message size of $|addr|+XXX + 3 \cdot 8 \cdot 32 + XXX$. We have $c_{cmp} = 2\cdot (r+m) \cdot c_{CTR} $, $c_{client}=x$, $c_{mix}= (2r+m)\cdot n$. The total communication cost is $c_{com}= (2r+m)\cdot n + c_{client}$.

\section{Security Proof}\label{Security}

We first remark that all of the eviction metadata is independent of data content, it is entirely determined by the sole parameter $n$ and is the same for any access. The data content is also never revealed to the adversary and is refreshed upon reception by every mix.
We argue that the adversary can win the game in only two ways: decrypting the records or finding out the record order before eviction. 

\subsection{In Search of the Lost Order.}
The client has sent to each mix private, and potentially public, group elements chosen as random from which the permutation keys are retrieved. The randomness of the seeds was increased thanks to the use of a key derivation function.\\

\noindent\textbf{Cascade mixnet.}
In this architecture, the whole database is sent from a mix to another. To know the index of any block, the adversary needs to retrieve the group elements sent to the uncompromised mixes. \\

\noindent\textbf{Parallel mixnet.}
In this architecture, chunks of the database are exchanged between mixes. The adversary can benefit of it as some records may never go to uncompromised mixes.\\
Goodrich in 2012 ~\cite{goodrich2012anonymous}, proved the security of such scheme using the sum of squares metric. If we note by $p(i,t)$ the probability the adversary thinks that the a particular card is at index $i$ at round $t$, $m-m_a$ the number of uncorrupted server(s) and by $\Phi(t)= \sum_{i}^{n}\left (p(i,t) - 1/n \right)^2$ the sum of squares metric, we have that $$E[\Phi(t)] = \left (1 - (m-m_a) \cdot \frac{k-1}{n-1}\right )^{t}$$\\
To have $\Phi(t) \leq n^{-c}$ with $m-m_a=1$, we need $cm \log n \leq r \leq 2cm \log(n)$, the upper bound being the value we propose in Section~\ref{kRTS}. The value we propose in Theorem~\ref{sec:kOM}, $\frac{m}{2} \cdot log\left ( \frac{n}{s} \right )$, accounts for the indistinguishability assumption we made: we do not want to hide the position of every record, only the position of $s$ of them (the accessed ones). ?

\subsection{In Search of the Lost Key.}
We assume here the adversary knows the invariant position of some of the records he asked the user to query. 

\noindent\textbf{The CBC case.}
In the CBC case, the blocks and IVs are encrypted again and again with AES in CBC mode. If a block was accessed, it is however encrypted only once by the user before the eviction.\\

\noindent\textbf{The CTR case.}
In the case of CTR, the adversary only needs to discover the uncompromised mixes' bindings. 

uncompromised mix blindings are never known by the adversary as the records are encrypted with AES-CTR when being (un)blinded. Thereby, the records after the unwrapping are undistinguishable from random arrays, and the adversary cannot see which records were accessed.

\section{Evaluation}\label{Evaluation}
\subsection{Implementation and Benchmark}\label{Implementation}
\subsection{Performances}\label{Performance}
performance per enc, performance per design, performance with implementation
\subsection{Comparison}\label{Comparison}
Comparison of CBC and tagging

\begin{table}
\centering
\begin{tabular}{*4c}
\toprule
    				& $C_{comp}$  	 & $C_{comm}$		& $C_{access}$\\
\midrule
Cascade - CBC   &  17.5 		& 19.1   		& 17.5  \\
Cascade - CTR   &  11.8 		& 12.7   		& 29.3  \\
Parallel - CBC  &  6.6  		&  5.6   		& 35.9  \\
Parallel - CTR  &  6.6  		&  5.6   		& 35.9  \\
\bottomrule
\end{tabular}
\caption{Cost comparison of designs.}
\end{table}
\quad
\begin{table}
\centering
\begin{tabular}{*4c}
\toprule
    				& $m=3$  	 & $m=5$		& $m=7$\\
\midrule
Cascade - CBC   &  17.5 		& 19.1   		& 17.5  \\
Cascade - CTR   &  11.8 		& 12.7   		& 29.3  \\
Parallel - CBC  &  6.6  		&  5.6   		& 35.9  \\
Parallel - CTR  &  6.6  		&  5.6   		& 35.9  \\
\bottomrule
\end{tabular}
\caption{Time comparison of designs,\\with $n=\frac{1024^3}{4\cdot 1024}$, $s=\sqrt n$.}
\end{table}


\section{Discussion}\label{Discussion}

\subsection{Active Adversary}\label{Active Adversary}
As misbehaving mixes are already discarded in the eviction setup, we could integrate in the client a light-weight local mix reputation system.
Randomized Partial Checking


\subsection{Differentially Private Oblivious Shuffle}\label{DPOS}
We could ask the mixes to process only a fraction of rounds $r \approx \frac{n}{2\cdot k }  \cdot \log \left (\frac{n}{s}-0.5 \right)$ to increase even more the efficiency of the eviction.

In the worst case scenario where an adversary $\mathcal{A}$ controls all but one mixes, the probability  $\mathcal{A}$ knows where a record is at the end of the eviction is $\delta= \Pr \left ( \mathcal{A} \text{ knows a record index}\right ) = \left ( 1 - \frac{1}{m} \right )^r$ where is $r$ the number of rounds.

To prevent such case, we can make each mix permute every allocated sections of the database and then begins the Oblivious Merge. We would thus add $2 \cdot m^2$ permutations for the whole eviction....

\section{Acknowledgement}
Danezis was supported by H2020  PANORAMIX Grant (ref. 653497) and EPSRC Grant EP/M013286/1; and Toledo by Microsoft Research.


\section{Conclusion}\label{Conclusion}
\begin{itemize}
 \item New ORAM with mix-net
 \item amortizable eviction
 \item can fetch while eviction running
 \item multi-user friendly as all the secrets are on the server
\end{itemize}

\bibliography{mix_oram}
\bibliographystyle{splncs03}

\section{Appendix}
\subsection{Proof $k$-RTS}\label{proof:kRTS}
\begin{proof}
To first prove the upper bound and variance, we use Diaconis et al. results~\cite{aldous1986shuffling} which states that $\tau$ defined in the following game is a strong stationary time.
In a random transposition shuffle, the cards chosen by the right and left hands at time $t$ are respectively called $R_t$ and $L_t$. Assuming that when $t=0$, no card is marked, we mark $R_t$ if
$R_t$ was unmarked before and either $L_t$ is marked or $L_t = R_t$. The variable $\tau$ represents the time when every card has been marked, we call it the stopping time.

Let be $\tau_t$ the number of transpositions after the $t^{th}$ card is marked, up to and including when the $(t+1)^{th}$ is marked. $$\tau = \sum_{i=0}^{n-1} \tau_i$$
The $\tau_t$ are independent geometric variables with probability of success $p_t$ as implied by the game rules.
The probability of success corresponds to the probability of marking at least one card, one to $t$ cards exactly. To do so, the right cards must be chosen from the unmarked set, comprising $n-t$ cards at time $t$,
and the left cards from the union of the marked set and the right cards.
\begin{align*}
 p_t &= \sum_{i=1}^{min(k,n-t)} {k \choose i} \cdot {t+1 \choose i} \cdot {n-t \choose i}\cdot{n \choose i}^{-2}&\\
 &= \frac{1}{n^2} \cdot \left ( k \cdot (t+1)\cdot(n-t) + \alpha_{n,t,k}\right ),\ 0 < \alpha_{n,t,k} = \mathcal{O}\left(n^{-k}\right )
\end{align*}

We can thus rewrite $\tau$'s expectation as following.
\begin{align*}
 E(\tau) &= \sum_{t=0}^{n-1} \frac{1}{p_{t}} = \sum_{t=0}^{n-1} \frac{n^2}{k \cdot (t+1)\cdot(n-t) + \alpha_{n,t,k}}&\\
 &< \sum_{t=0}^{n-1} \frac{n^2}{k \cdot (t+1)\cdot(n-t)}  &\\
 &< \frac{1}{k} \cdot \frac{n^2}{n+1} \cdot  \sum_{t=0}^{n-1} \left ( \frac{1}{t+1} + \frac{1}{n-t} \right ) &\\
% &< \frac{2}{k} \cdot \frac{n^2}{n+1} \cdot H_n  \\
 &< \frac{2}{k} \cdot \frac{n^2}{n+1} \cdot \left( \ln(n) + \gamma +\mathcal{O}(\frac{1}{n}) \right), \gamma = \lim_{n \to \infty} H_n - \ln(n)& \\
 \end{align*}
 \begin{align*}
 var(\tau) &= \sum_{t=0}^{n-1}\frac{1-p_t}{{p_t}^2}\ <\  \sum_{t=0}^{n-1}\frac{1}{{p_t}^2} &\\
 &< \sum_{t=0}^{n-1}\frac{1}{\left ( k \frac{(t+1)\cdot(n-t)}{n^2} + \alpha_{n,t,k}\right )^2}\\\
 &<\ \sum_{t=0}^{n-1} \frac{1 }{\left ( k \frac{(t+1)\cdot(n-t)}{n^2} \right )^2} &\\
 %&< \frac{n^4}{k^2} \left ( \sum_{t=0}^{\frac{n}{2}-1} \frac{1}{\left ( (t+1)(n-t)\right )^2}  + \sum_{t=\frac{n}{2}}^{n-1} \frac{1}{\left ( (t+1)(n-t)\right )^2} \right ) &\\
 &< 2 \cdot \left (\frac{n}{k} \right )^2 \cdot \left (\frac{n}{n/2} \right )^2 \cdot \sum_{t=0}^{n/2-1} \frac{1}{(t+1)^2} &\\
 &< \frac{4}{3} \pi^2 \cdot \left (\frac{n}{k} \right )^2 
\end{align*}
\\

To now prove the lower bound of $\tau$, we will compare the number of fixed points of a permutation $\sigma$, $F(\sigma)$, for our shuffle, the permutation
obtained from the identity by applying $kt$ random transpositions $ P^{kt}(id, \cdot)$, and the uniform distribution $\pi$, or more precisely compare the corresponding probabilities over the set $A=\{\sigma : F(\sigma) \geq \frac{\mu}{2} \}$.
We can say that after $t$ shuffles, the number of untouched cards of our shuffle has the same distribution as the number $R_{2kt}$ of uncollected coupon types after $2kt$ steps of a coupon collector chain
and that about $ P^{kt}(id, \cdot)$ that the associate $F(\sigma)$ is at least as large as the number of cards that were touched by none of the transpositions, i.e. $P^{kt}(id,A) \geq P(R_{kt}\geq A) $.

We know that the $R_{2kt}$ has expectation $\mu = np$  with $p=\left ( 1 - \frac{1}{n} \right )^{2kt}$, variance $var = np(1-p) <\mu$ and by Chebyshev, we know that $\Pr(R_{2kt}\leq \frac{\mu}{2})\leq \frac{4}{\mu}$
as $\Pr(|R_{2kt} - \mu|\geq \frac{\mu}{2}) = \Pr(R_{2kt} \geq \frac{3\mu}{2}) + \Pr(R_{2kt} \leq \frac{\mu}{2}) > \Pr(R_{2kt} \leq \frac{\mu}{2})$.\\

By Markov's inequality we know that $\pi(A) \leq \frac{2}{\mu}$.\\

As $P^{kt}(id,A) \geq P(R_{kt}\geq A) $, we also have $P^{kt}(id,A^c) \leq P(R_{2kt}\leq A) \leq \frac{4}{\mu} $ which leads to $P^{kt}(id,A)\geq1 - \frac{4}{\mu}$.\\

Thus we have $d(t)=||P^{kt}(id,) - \pi ||_{TV} \geq |1 - \frac{4}{\mu} - \frac{2}{\mu}| \geq 1 - \frac{6}{\mu}$.\\

We want to find the minimum $t$ such that $1-\frac{6}{\mu}\geq \epsilon$, which is equivalent to $n \cdot \left ( 1 - \frac{1}{n} \right )^{2kt} \geq \frac{6}{1-\epsilon}$ and to
$$\log\left(\frac{n\cdot (1-\epsilon)}{6}\right) \geq 2\cdot k\cdot t \cdot \log \left ( \frac{n}{n-1} \right )$$
As $\log(1+x) \leq x$, the previous inequality holds if $\log\left(\frac{n\cdot (1-\epsilon)}{6}\right) \geq   \frac{2kt}{n-1} $ which means that if $t\leq \frac{n-1}{2k}\cdot \log\left ( \frac{n(1-\epsilon)}{6}\right )$ then $d(t)\geq \epsilon$.
Thus,
$$\tau \left (\epsilon \right ) \geq \frac{n-1}{2k} \ln(n\cdot \frac{1-\epsilon}{6}) $$.
\end{proof}

\subsection{Proof of Oblivious Merge}\label{proof:OM}
\begin{proof}
We want to find the mixing time $\tau(\epsilon)$ of our oblivious merge of two sets of indistinguishable elements. To do so, we use the bound of the mixing time of an irreducible ergodic Markov Chain, where $p = \frac{1}{|V|}$ and $1-\lambda^*$ is the spectral gap,
$$\frac{\lambda^*}{1-\lambda^*} \cdot \log\left(\frac{1}{2 \epsilon} \right)\leq \tau(\epsilon) \leq \frac{1}{1-\lambda^*}\cdot \log \left( \frac{1}{2 \epsilon \cdot \sqrt{p}}\right) $$

We now want to find a bound for $\lambda^*$. We represent the arranging of merge of the 2 distinct sets by the graph $\mathcal{G}$, a $k$-regular graph with $v$ vertices corresponding to the different orderings and the undirected edges to transpositions of two elements.
By definition, the eigenvalues of the transition matrix of the $\mathcal{G}$ are $k={\lambda'}_0 > {\lambda'}_1 \geq  ... \geq {\lambda'}_{n-1}$, and we have,
$$\text{diam}\left( \mathcal{G}\right) \leq \frac{log(v-1)}{log(\frac{k}{{\lambda'}^*})}+1 \text{ with } {\lambda'}^* = max_{i\neq0}({\lambda'}_i)= k \cdot \lambda^*$$
with $diam\left( \mathcal{G} \right)=s$ the diameter of the graph, $v= {n \choose s}$ the number of vertices and $k=s\cdot(n-s)$.\\


We can thus find a first relation:
\begin{align*}
log(\frac{k}{{\lambda'}^*}) &= log(\frac{1}{{\lambda}^*}) \leq\frac{\log(v-1)}{\text{diam}\left(\mathcal{G}\right)-1}&\\
log({{\lambda}^*}) &\geq  \frac{log(v-1)}{1-\text{diam}\left(\mathcal{G}\right)}&\\
{\lambda}^* &\geq (v-1)^{\frac{-1}{\text{diam}\left(\mathcal{G}\right)-1}}\\
{\lambda}^* &\geq \left ({n \choose s}-1 \right )^{\frac{1}{1-s}} \geq \left (\frac{n\cdot e}{s} \right )^{\frac{s}{1-s}}
\end{align*}

And can derive the minimum value of $\Delta=\frac{\lambda^*}{1-\lambda^*}$,
\begin{align*}
 \Delta &= \frac{1}{\left (\lambda^*\right )^{-1}-1}\\
 &\geq \frac{1}{\left (\frac{n \cdot e }{s} \right )^{\frac{s}{s-1}}-1}\\
\end{align*}


To find an upper-bound of $\lambda^*$, we will focus on the spectral gap bounding.
Let's $\mathcal{G}_{0,1}=\{0,1\}^n$ be the group of elements with the XOR operation and $\mathcal{S}=\{x \in \mathcal{G},\ weight(x)=s\}$ the symmetric subset of $\mathcal{G}$ of n-binary array with $s$ 1s and $n-s$ 0s.
We call $Cay_{n,s}=Graph\left(  \mathcal{G}_{0,1}, \mathcal{S} \right) $ the Cayley graph generated from these structures.

\begin{lemma}
Let $\mathcal{G}$ be a finite Abelian group, $\chi\ :\  \mathcal{G} \rightarrow \mathbb{C}$ be a character of $\mathcal{G}$, $\mathcal{S} \subseteq \mathcal{G}$ be a symmetric set.
Let $M$ be the normalized adjacency matrix of the Cayley graph $G = Cay(\mathcal{G},\mathcal{S})$.
Consider the vector $x \in \mathbb{C}^\mathcal{G}$ such that $x_a = \chi(a)$. Then x is an eigenvector of $G$, with eigenvalue $$ \frac{1}{\mathcal{S}} \sum_{s\in \mathcal{S}} \chi\left(s\right)$$
\end{lemma}

\begin{theorem}
The Cayley graph $Cay_{n,s}$ has for eigenvalues $\mu_0 = 1 > \mu_1 \geq ... \geq \mu_n$ with, 
$$\mu_r = \frac{1}{\left | \mathcal{S} \right |} \sum_{i=1}^{min(r, n-r)} \left ( -1 \right )^i {r \choose i}{n-r \choose s-i}\\$$
\end{theorem}

\begin{subproof}
$\forall r \in \{0,1\}^n$, with $\chi_r(x)=\left ( -1 \right )^{\sum r_i \cdot x_i}$, we have,
\begin{align*}
\mu_r &= \frac{1}{\mathcal{S}} \sum_{s\in \mathcal{S}} \chi\left(s\right) \\
&= \frac{1}{\left | \mathcal{S} \right |} \sum_{s\in \mathcal{S}} \left ( -1 \right )^{\sum r_i \cdot s_i} \\
&=  \frac{1}{\left | \mathcal{S} \right |} \left ( \left | ``1" \right | - \left | ``-1"  \right| \right ) \\
&= \frac{1}{\left | \mathcal{S} \right |} \sum_{i=1}^{min(r, s)} \left ( -1 \right )^i {r \choose i}{n-r \choose s-i} \\
&= 1 - \frac{2}{{n \choose s}} \cdot \sum_{i=0}^{min(\frac{r-1}{2}, \frac{s-1}{2})} {r \choose 1+2i}{n-r \choose s-2i-1} \\
&= \frac{{n-r \choose s}}{{n \choose s}} \ _2F_1(-r,-s,n-2r+1,-1)
%&= \frac{1}{\left | \mathcal{S} \right |} \left [ \sum_{i=0}^{min(\frac{r}{2},\frac{n-r}{2})} {r \choose 2i}{n-r \choose s-2i} - \sum_{i=0}^{min(\frac{r-1}{2}, \frac{n-r-1}{2})} {r \choose 1+2i}{n-r \choose s-2i-1}\right] 
\end{align*}
\end{subproof}


Remark. We recognize here the Vandermonde identity with alternating numbers. We argue that the eigenvalues of the Cayley graph $Cay_{n,s}$ are all positive as the smallest eigenvalue is null.
For $r=n-r$, the expression simplifies to $\mu_r = {r \choose \frac{n}{2}}$ if $n$ even, 0 otherwise.
For $r=1$, the expression simplifies to $\mu_1 = 1 - 2\cdot \frac{s}{n}$, the spectral gap of $Cay_{n,s}$ is thus equal to $2\cdot \frac{s}{n}$.\\\

We notice that the first graph $\mathcal{G}$ actually is a sub-graph of $Cay_{n,s}$ and as such the the adjacent matrix of the first graph is included in the second's.
For $s>1$, $Cay_{n,s}$ is divided in two sub-graphs representing the cosets of $\{0,1\}^n$ as $\mathcal{S}$ is not a generating group of $\mathcal{G}_{0,1}$, $\mathcal{G}$ is only contained in one of the sub-graphs.
We use the Cauchy's Interlace Theorem to bound the eigenvalues of $\mathcal{G}$ with the ones of $Cay_{n,s}$,.

\begin{theorem}
Let $M$ be a Hermitian $n \times n$ matrix with eigenvalues ${\mu'}_0\geq ... \geq {\mu'}_{n-1}$ and $N$ a $m \times m$ sub-matrix of $M$ with eigenvalues ${\lambda'}_0\geq ... \geq {\lambda'}_{m-1}$ , we have
$$ {\mu'}_i \geq {\lambda'}_i \geq {\mu'}_{n-m+i+1} $$
\end{theorem}

We are here only interested in an upper-bound of $\lambda*$, as we have $\mu_{2^n+2-{n \choose s}}\leq \lambda_1\leq 1-2\frac{s}{n}$ and $0 \leq \lambda_n \leq \mu_2$, $\lambda* \leq 1-2\frac{s}{n}$. We thus have $\frac{1}{1-\lambda*}\leq\frac{n}{2\cdot s}$
\end{proof}

\subsection{Proof of Fake access}
\begin{proof}
 We want to prove that the average number of fake access is 0 in case of a uniform distribution. To do so, we consider the Markov chain and its Transition Matrix.
 The transition matrix $P$ represents the $s$ transient state, in which the stash is not completely filled, and the absorption state in which the stash is full.
Thus, $P$ can be decomposed in 4 sub-matrices: the square sub-matrix $Q_s$ representing all the transient state, the column matrix R with the probabilities of transitioning to the absorbing state, the null row matrix and the absorption matrix.
\[
\begin{bmatrix}
   Q_s & R \\
   0_{1\times s}   & I_1 \\
\end{bmatrix}
\]
To find the average number of steps from one state to the absorbing one, we have solve the following equation, each row corresponding to the average number of steps from the corresponding state (the stashed filled with some records) to the state where the stash is full.
\begin{align*}
 t &= \left (\sum_{k=0}^{\infty} {Q_s}^k \right ) 1 \\
   &= (I_s -Q_s )^{-1} 1
\end{align*}
This equation has a solution since $M=I_s -Q_s$ have independent rows and thus an inverse that we call $N$.
By calculus we find that,
\begin{align*}
 n_{i,j} &= 0 &\text{ if } i>j,\\ 
 n_{i,j} &= \frac{1}{m_{i,i}} &\text{ if } i=j,\\
 n_{i,j} &= - n_{i+1,j } \cdot \frac{m_{i,i+1}}{m_{i,i}} &\text{ if } i<j 
\end{align*}
which can be simplified by
\begin{align*}
 n_{i,j} &= 0 &\text{ if } i>j,\\ 
 n_{i,j} &= \frac{1}{m_{j,j}} \prod_{k=1}^{j-1} \left ( - \frac{m_{i,k+1}}{m_{k,k}}\right ) &\text{ if } i\leq j
\end{align*}
We only want to calculate the first solution $S_1$ from the equation.
\begin{align*}
 S_1 &= \sum_{j=0}^{s-1} \frac{1}{m_{j,j}} \prod_{k=1}^{j-1} \left ( - \frac{m_{i,k+1}}{m_{k,k}}\right ) \\
     &= \sum_{j=1}^{s-1} \frac{1}{m_{j,j}} \text{ as } m_{i,k+1}= -m_{k,k} \\
     &= \sum_{j=0}^{s-1} \frac{1}{1-\frac{j}{n}} = \sum_{j=0}^{s-1} \left (1 + \frac{j}{n-j} \right ) \\
     &= s + \sum_{j=0}^{s-1} \frac{j}{n-j} \\   
\end{align*}
As $s$ steps are required to fill the stash, we thus find the following inequality for the number of fake access $f$:
$$ \frac{s \cdot (s+1)}{2 \cdot n} < f < \frac{s \cdot (s+1)}{2 \cdot (n+1-s)} $$
\end{proof}


\end{document}